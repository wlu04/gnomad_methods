<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gnomad.utils.vcf &mdash; gnomad master documentation</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> gnomad
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resource_sources.html">Resource Sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Change Log</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">gnomad</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>gnomad.utils.vcf</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gnomad.utils.vcf</h1><div class="highlight"><pre>
<span></span><span class="c1"># noqa: D100</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">hail</span> <span class="k">as</span> <span class="nn">hl</span>

<span class="kn">from</span> <span class="nn">gnomad.sample_qc.ancestry</span> <span class="kn">import</span> <span class="n">POP_NAMES</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(levelname)s</span><span class="s2"> (</span><span class="si">%(name)s</span><span class="s2"> </span><span class="si">%(lineno)s</span><span class="s2">): </span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>

<span class="n">SORT_ORDER</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;subset&quot;</span><span class="p">,</span>
    <span class="s2">&quot;downsampling&quot;</span><span class="p">,</span>
    <span class="s2">&quot;popmax&quot;</span><span class="p">,</span>
    <span class="s2">&quot;pop&quot;</span><span class="p">,</span>
    <span class="s2">&quot;subpop&quot;</span><span class="p">,</span>
    <span class="s2">&quot;sex&quot;</span><span class="p">,</span>
    <span class="s2">&quot;group&quot;</span><span class="p">,</span>
<span class="p">]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Order to sort subgroupings during VCF export.</span>
<span class="sd">Ensures that INFO labels in VCF are in desired order (e.g., raw_AC_afr_female).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">GROUPS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;adj&quot;</span><span class="p">,</span> <span class="s2">&quot;raw&quot;</span><span class="p">]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Group names used to generate labels for high quality genotypes and all raw genotypes. Used in VCF export.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">HISTS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;gq_hist_alt&quot;</span><span class="p">,</span> <span class="s2">&quot;gq_hist_all&quot;</span><span class="p">,</span> <span class="s2">&quot;dp_hist_alt&quot;</span><span class="p">,</span> <span class="s2">&quot;dp_hist_all&quot;</span><span class="p">,</span> <span class="s2">&quot;ab_hist_alt&quot;</span><span class="p">]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Quality histograms used in VCF export.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">FAF_POPS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;afr&quot;</span><span class="p">,</span> <span class="s2">&quot;amr&quot;</span><span class="p">,</span> <span class="s2">&quot;eas&quot;</span><span class="p">,</span> <span class="s2">&quot;nfe&quot;</span><span class="p">,</span> <span class="s2">&quot;sas&quot;</span><span class="p">]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Global populations that are included in filtering allele frequency (faf) calculations. Used in VCF export.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">SEXES</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;XX&quot;</span><span class="p">,</span> <span class="s2">&quot;XY&quot;</span><span class="p">]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Sample sexes used in VCF export.</span>

<span class="sd">Used to stratify frequency annotations (AC, AN, AF) for each sex.</span>
<span class="sd">Note that sample sexes in gnomAD v3 and earlier were &#39;male&#39; and &#39;female&#39;.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">AS_FIELDS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;AS_FS&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AS_MQ&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AS_MQRankSum&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AS_pab_max&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AS_QUALapprox&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AS_QD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AS_ReadPosRankSum&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AS_SB_TABLE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AS_SOR&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AS_VarDP&quot;</span><span class="p">,</span>
    <span class="s2">&quot;InbreedingCoeff&quot;</span><span class="p">,</span>
<span class="p">]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Allele-specific variant annotations.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">SITE_FIELDS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;FS&quot;</span><span class="p">,</span>
    <span class="s2">&quot;MQ&quot;</span><span class="p">,</span>
    <span class="s2">&quot;MQRankSum&quot;</span><span class="p">,</span>
    <span class="s2">&quot;QUALapprox&quot;</span><span class="p">,</span>
    <span class="s2">&quot;QD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ReadPosRankSum&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SB&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SOR&quot;</span><span class="p">,</span>
    <span class="s2">&quot;VarDP&quot;</span><span class="p">,</span>
<span class="p">]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Site level variant annotations.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">ALLELE_TYPE_FIELDS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;allele_type&quot;</span><span class="p">,</span>
    <span class="s2">&quot;has_star&quot;</span><span class="p">,</span>
    <span class="s2">&quot;n_alt_alleles&quot;</span><span class="p">,</span>
    <span class="s2">&quot;original_alleles&quot;</span><span class="p">,</span>
    <span class="s2">&quot;variant_type&quot;</span><span class="p">,</span>
    <span class="s2">&quot;was_mixed&quot;</span><span class="p">,</span>
<span class="p">]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Allele-type annotations.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">REGION_FLAG_FIELDS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;decoy&quot;</span><span class="p">,</span> <span class="s2">&quot;lcr&quot;</span><span class="p">,</span> <span class="s2">&quot;nonpar&quot;</span><span class="p">,</span> <span class="s2">&quot;segdup&quot;</span><span class="p">]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Annotations about variant region type.</span>

<span class="sd">.. note::</span>
<span class="sd">    decoy resource files do not currently exist for GRCh38/hg38.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">RF_FIELDS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;rf_positive_label&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rf_negative_label&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rf_label&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rf_train&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rf_tp_probability&quot;</span><span class="p">,</span>
<span class="p">]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Annotations specific to the variant QC using a random forest model.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">AS_VQSR_FIELDS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;AS_culprit&quot;</span><span class="p">,</span> <span class="s2">&quot;AS_VQSLOD&quot;</span><span class="p">]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Allele-specific VQSR annotations.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">VQSR_FIELDS</span> <span class="o">=</span> <span class="n">AS_VQSR_FIELDS</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;NEGATIVE_TRAIN_SITE&quot;</span><span class="p">,</span> <span class="s2">&quot;POSITIVE_TRAIN_SITE&quot;</span><span class="p">]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Annotations specific to VQSR.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">INFO_VCF_AS_PIPE_DELIMITED_FIELDS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;AS_QUALapprox&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AS_VarDP&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AS_MQ_DP&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AS_RAW_MQ&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AS_SB_TABLE&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">INFO_DICT</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;FS&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Phred-scaled p-value of Fisher&#39;s exact test for strand bias&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;InbreedingCoeff&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Inbreeding coefficient, the excess heterozygosity at a variant site, computed as 1 - (the number of heterozygous genotypes)/(the number of heterozygous genotypes expected under Hardy-Weinberg equilibrium)&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;MQ&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Root mean square of the mapping quality of reads across all samples&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;MQRankSum&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Z-score from Wilcoxon rank sum test of alternate vs. reference read mapping qualities&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;QD&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Variant call confidence normalized by depth of sample reads supporting a variant&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;ReadPosRankSum&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Z-score from Wilcoxon rank sum test of alternate vs. reference read position bias&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;SOR&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Strand bias estimated by the symmetric odds ratio test&quot;</span><span class="p">},</span>
    <span class="s2">&quot;POSITIVE_TRAIN_SITE&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Variant was used to build the positive training set of high-quality variants for VQSR&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;NEGATIVE_TRAIN_SITE&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Variant was used to build the negative training set of low-quality variants for VQSR&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;BaseQRankSum&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Z-score from Wilcoxon rank sum test of alternate vs. reference base qualities&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;VarDP&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Depth over variant genotypes (does not include depth of reference samples)&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;VQSLOD&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Log-odds ratio of being a true variant versus being a false positive under the trained VQSR Gaussian mixture model&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;culprit&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Worst-performing annotation in the VQSR Gaussian mixture model&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;decoy&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Variant falls within a reference decoy region&quot;</span><span class="p">},</span>
    <span class="s2">&quot;lcr&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Variant falls within a low complexity region&quot;</span><span class="p">},</span>
    <span class="s2">&quot;nonpar&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Variant (on sex chromosome) falls outside a pseudoautosomal region&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;segdup&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Variant falls within a segmental duplication region&quot;</span><span class="p">},</span>
    <span class="s2">&quot;rf_positive_label&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Variant was labelled as a positive example for training of random forest model&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;rf_negative_label&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Variant was labelled as a negative example for training of random forest model&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;rf_label&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Random forest training label&quot;</span><span class="p">},</span>
    <span class="s2">&quot;rf_train&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Variant was used in training random forest model&quot;</span><span class="p">},</span>
    <span class="s2">&quot;rf_tp_probability&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Probability of a called variant being a true variant as determined by random forest model&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;transmitted_singleton&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Variant was a callset-wide doubleton that was transmitted within a family from a parent to a child (i.e., a singleton amongst unrelated samples in cohort)&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;original_alleles&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Alleles before splitting multiallelics&quot;</span><span class="p">},</span>
    <span class="s2">&quot;variant_type&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Variant type (snv, indel, multi-snv, multi-indel, or mixed)&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;allele_type&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Allele type (snv, insertion, deletion, or mixed)&quot;</span><span class="p">,},</span>
    <span class="s2">&quot;n_alt_alleles&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Total number of alternate alleles observed at variant locus&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;was_mixed&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Variant type was mixed&quot;</span><span class="p">},</span>
    <span class="s2">&quot;has_star&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Variant locus coincides with a spanning deletion (represented by a star) observed elsewhere in the callset&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;AS_pab_max&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Maximum p-value over callset for binomial test of observed allele balance for a heterozygous genotype, given expectation of 0.5&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;monoallelic&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;All samples are homozygous alternate for the variant&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;QUALapprox&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Sum of PL[0] values; used to approximate the QUAL score&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;AS_SB_TABLE&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Allele-specific forward/reverse read counts for strand bias tests&quot;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Dictionary used during VCF export to export row (variant) annotations.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">IN_SILICO_ANNOTATIONS_INFO_DICT</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;cadd_raw_score&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Raw CADD scores are interpretable as the extent to which the annotation profile for a given variant suggests that the variant is likely to be &#39;observed&#39; (negative values) vs &#39;simulated&#39; (positive values). Larger values are more deleterious.&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;cadd_phred&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Cadd Phred-like scores (&#39;scaled C-scores&#39;) ranging from 1 to 99, based on the rank of each variant relative to all possible 8.6 billion substitutions in the human reference genome. Larger values are more deleterious.&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;revel_score&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;dbNSFP&#39;s Revel score from 0 to 1. Variants with higher scores are predicted to be more likely to be deleterious.&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;splice_ai_max_ds&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Illumina&#39;s SpliceAI max delta score; interpreted as the probability of the variant being splice-altering.&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;splice_ai_consequence&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;The consequence term associated with the max delta score in &#39;splice_ai_max_ds&#39;.&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;primate_ai_score&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;PrimateAI&#39;s deleteriousness score from 0 (less deleterious) to 1 (more deleterious).&quot;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Dictionary with in silico score descriptions to include in the VCF INFO header.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">ENTRIES</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;GT&quot;</span><span class="p">,</span> <span class="s2">&quot;GQ&quot;</span><span class="p">,</span> <span class="s2">&quot;DP&quot;</span><span class="p">,</span> <span class="s2">&quot;AD&quot;</span><span class="p">,</span> <span class="s2">&quot;MIN_DP&quot;</span><span class="p">,</span> <span class="s2">&quot;PGT&quot;</span><span class="p">,</span> <span class="s2">&quot;PID&quot;</span><span class="p">,</span> <span class="s2">&quot;PL&quot;</span><span class="p">,</span> <span class="s2">&quot;SB&quot;</span><span class="p">]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Densified entries to be selected during VCF export.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">SPARSE_ENTRIES</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;END&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DP&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GQ&quot;</span><span class="p">,</span>
    <span class="s2">&quot;LA&quot;</span><span class="p">,</span>
    <span class="s2">&quot;LAD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;LGT&quot;</span><span class="p">,</span>
    <span class="s2">&quot;LPGT&quot;</span><span class="p">,</span>
    <span class="s2">&quot;LPL&quot;</span><span class="p">,</span>
    <span class="s2">&quot;MIN_DP&quot;</span><span class="p">,</span>
    <span class="s2">&quot;PID&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RGQ&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SB&quot;</span><span class="p">,</span>
<span class="p">]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Sparse entries to be selected and densified during VCF export.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">FORMAT_DICT</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;GT&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Genotype&quot;</span><span class="p">,</span> <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;Type&quot;</span><span class="p">:</span> <span class="s2">&quot;String&quot;</span><span class="p">},</span>
    <span class="s2">&quot;AD&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Allelic depths for the ref and alt alleles in the order listed&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Type&quot;</span><span class="p">:</span> <span class="s2">&quot;Integer&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;DP&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Approximate read depth (reads with MQ=255 or with bad mates are filtered)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Type&quot;</span><span class="p">:</span> <span class="s2">&quot;Integer&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;GQ&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Phred-scaled confidence that the genotype assignment is correct. Value is the difference between the second lowest PL and the lowest PL (always normalized to 0).&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Type&quot;</span><span class="p">:</span> <span class="s2">&quot;Integer&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;MIN_DP&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Minimum DP observed within the GVCF block&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Type&quot;</span><span class="p">:</span> <span class="s2">&quot;Integer&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;PGT&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Physical phasing haplotype information, describing how the alternate alleles are phased in relation to one another&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Type&quot;</span><span class="p">:</span> <span class="s2">&quot;String&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;PID&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Physical phasing ID information, where each unique ID within a given sample (but not across samples) connects records within a phasing group&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Type&quot;</span><span class="p">:</span> <span class="s2">&quot;String&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;PL&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Normalized, phred-scaled likelihoods for genotypes as defined in the VCF specification&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;G&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Type&quot;</span><span class="p">:</span> <span class="s2">&quot;Integer&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;SB&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Per-sample component statistics which comprise the Fisher&#39;s exact test to detect strand bias. Values are: depth of reference allele on forward strand, depth of reference allele on reverse strand, depth of alternate allele on forward strand, depth of alternate allele on reverse strand.&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Type&quot;</span><span class="p">:</span> <span class="s2">&quot;Integer&quot;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Dictionary used during VCF export to export MatrixTable entries.</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="adjust_vcf_incompatible_types"><a class="viewcode-back" href="../../../api_reference/utils/vcf.html#gnomad.utils.vcf.adjust_vcf_incompatible_types">[docs]</a><span class="k">def</span> <span class="nf">adjust_vcf_incompatible_types</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">pipe_delimited_annotations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">INFO_VCF_AS_PIPE_DELIMITED_FIELDS</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a Table ready for vcf export.</span>

<span class="sd">    In particular, the following conversions are done:</span>
<span class="sd">        - All int64 are coerced to int32</span>
<span class="sd">        - Fields specified by `pipe_delimited_annotations` are converted from arrays to pipe-delimited strings</span>

<span class="sd">    :param ht: Input Table.</span>
<span class="sd">    :param pipe_delimited_annotations: List of info fields (they must be fields of the ht.info Struct).</span>
<span class="sd">    :return: Table ready for VCF export.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_pipe_expr</span><span class="p">(</span><span class="n">array_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="n">array_expr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s2">&quot;&quot;</span><span class="p">)),</span> <span class="s2">&quot;|&quot;</span><span class="p">)</span>

    <span class="c1"># Make sure the HT is keyed by locus, alleles</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;locus&quot;</span><span class="p">,</span> <span class="s2">&quot;alleles&quot;</span><span class="p">)</span>

    <span class="n">info_type_convert_expr</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Convert int64 fields to int32 (int64 isn&#39;t supported by VCF)</span>
    <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">ft</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">ft</span> <span class="o">==</span> <span class="n">hl</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Coercing field info.</span><span class="si">%s</span><span class="s2"> from int64 to int32 for VCF output. Value will be capped at int32 max value.&quot;</span><span class="p">,</span>
                <span class="n">f</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">info_type_convert_expr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ht</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">f</span><span class="p">]))}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">ft</span> <span class="o">==</span> <span class="n">hl</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;array&lt;int64&gt;&quot;</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Coercing field info.</span><span class="si">%s</span><span class="s2"> from array&lt;int64&gt; to array&lt;int32&gt; for VCF output. Array values will be capped &quot;</span>
                <span class="s2">&quot;at int32 max value.&quot;</span><span class="p">,</span>
                <span class="n">f</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">info_type_convert_expr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">ht</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)))}</span>
            <span class="p">)</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">info_type_convert_expr</span><span class="p">))</span>

    <span class="n">info_expr</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Make sure to pipe-delimit fields that need to.</span>
    <span class="c1"># Note: the expr needs to be prefixed by &quot;|&quot; because GATK expect one value for the ref (always empty)</span>
    <span class="c1"># Note2: this doesn&#39;t produce the correct annotation for AS_SB_TABLE, it is handled below</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">pipe_delimited_annotations</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">info</span> <span class="ow">and</span> <span class="n">f</span> <span class="o">!=</span> <span class="s2">&quot;AS_SB_TABLE&quot;</span><span class="p">:</span>
            <span class="n">info_expr</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span> <span class="o">+</span> <span class="n">get_pipe_expr</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>

    <span class="c1"># Flatten SB if it is an array of arrays</span>
    <span class="k">if</span> <span class="s2">&quot;SB&quot;</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">info</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">SB</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">):</span>
        <span class="n">info_expr</span><span class="p">[</span><span class="s2">&quot;SB&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">SB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">SB</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="s2">&quot;AS_SB_TABLE&quot;</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
        <span class="n">info_expr</span><span class="p">[</span><span class="s2">&quot;AS_SB_TABLE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_pipe_expr</span><span class="p">(</span>
            <span class="n">ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">AS_SB_TABLE</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="c1"># Annotate with new expression</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">info_expr</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">ht</span></div>


<div class="viewcode-block" id="make_label_combos"><a class="viewcode-back" href="../../../api_reference/utils/vcf.html#gnomad.utils.vcf.make_label_combos">[docs]</a><span class="k">def</span> <span class="nf">make_label_combos</span><span class="p">(</span>
    <span class="n">label_groups</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">sort_order</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">SORT_ORDER</span><span class="p">,</span>
    <span class="n">label_delimiter</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make combinations of all possible labels for a supplied dictionary of label groups.</span>

<span class="sd">    For example, if label_groups is `{&quot;sex&quot;: [&quot;male&quot;, &quot;female&quot;], &quot;pop&quot;: [&quot;afr&quot;, &quot;nfe&quot;, &quot;amr&quot;]}`,</span>
<span class="sd">    this function will return `[&quot;afr_male&quot;, &quot;afr_female&quot;, &quot;nfe_male&quot;, &quot;nfe_female&quot;, &quot;amr_male&quot;, &quot;amr_female&#39;]`</span>

<span class="sd">    :param label_groups: Dictionary containing an entry for each label group, where key is the name of the grouping,</span>
<span class="sd">        e.g. &quot;sex&quot; or &quot;pop&quot;, and value is a list of all possible values for that grouping (e.g. [&quot;male&quot;, &quot;female&quot;] or [&quot;afr&quot;, &quot;nfe&quot;, &quot;amr&quot;]).</span>
<span class="sd">    :param sort_order: List containing order to sort label group combinations. Default is SORT_ORDER.</span>
<span class="sd">    :param label_delimiter: String to use as delimiter when making group label combinations.</span>
<span class="sd">    :return: list of all possible combinations of values for the supplied label groupings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">copy_label_groups</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">label_groups</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">copy_label_groups</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">copy_label_groups</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>
    <span class="n">anchor_group</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">copy_label_groups</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">sort_order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">))[</span>
        <span class="mi">0</span>
    <span class="p">]</span>
    <span class="n">anchor_val</span> <span class="o">=</span> <span class="n">copy_label_groups</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">anchor_group</span><span class="p">)</span>
    <span class="n">combos</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span>
        <span class="n">anchor_val</span><span class="p">,</span>
        <span class="n">make_label_combos</span><span class="p">(</span><span class="n">copy_label_groups</span><span class="p">,</span> <span class="n">label_delimiter</span><span class="o">=</span><span class="n">label_delimiter</span><span class="p">),</span>
    <span class="p">):</span>
        <span class="n">combos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">}{</span><span class="n">label_delimiter</span><span class="si">}{</span><span class="n">y</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">combos</span></div>


<div class="viewcode-block" id="index_globals"><a class="viewcode-back" href="../../../api_reference/utils/vcf.html#gnomad.utils.vcf.index_globals">[docs]</a><span class="k">def</span> <span class="nf">index_globals</span><span class="p">(</span>
    <span class="n">globals_array</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
    <span class="n">label_groups</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">label_delimiter</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a dictionary keyed by the specified label groupings with values describing the corresponding index of each grouping entry in the meta_array annotation.</span>

<span class="sd">    :param globals_array: Ordered list containing dictionary entries describing all the grouping combinations contained in the globals_array annotation.</span>
<span class="sd">       Keys are the grouping type (e.g., &#39;group&#39;, &#39;pop&#39;, &#39;sex&#39;) and values are the grouping attribute (e.g., &#39;adj&#39;, &#39;eas&#39;, &#39;XY&#39;).</span>
<span class="sd">    :param label_groups: Dictionary containing an entry for each label group, where key is the name of the grouping,</span>
<span class="sd">        e.g. &quot;sex&quot; or &quot;pop&quot;, and value is a list of all possible values for that grouping (e.g. [&quot;male&quot;, &quot;female&quot;] or [&quot;afr&quot;, &quot;nfe&quot;, &quot;amr&quot;])</span>
<span class="sd">    :param label_delimiter: String used as delimiter when making group label combinations.</span>
<span class="sd">    :return: Dictionary keyed by specified label grouping combinations, with values describing the corresponding index</span>
<span class="sd">        of each grouping entry in the globals</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">combos</span> <span class="o">=</span> <span class="n">make_label_combos</span><span class="p">(</span><span class="n">label_groups</span><span class="p">,</span> <span class="n">label_delimiter</span><span class="o">=</span><span class="n">label_delimiter</span><span class="p">)</span>
    <span class="n">index_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">combos</span><span class="p">:</span>
        <span class="n">combo_fields</span> <span class="o">=</span> <span class="n">combo</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">label_delimiter</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">globals_array</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">combo_fields</span><span class="p">):</span>
                <span class="n">index_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">combo</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">index_dict</span></div>


<div class="viewcode-block" id="make_combo_header_text"><a class="viewcode-back" href="../../../api_reference/utils/vcf.html#gnomad.utils.vcf.make_combo_header_text">[docs]</a><span class="k">def</span> <span class="nf">make_combo_header_text</span><span class="p">(</span>
    <span class="n">preposition</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">combo_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">pop_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Programmatically generate text to populate the VCF header description for a given variant annotation with specific groupings and subset.</span>

<span class="sd">    For example, if preposition is &quot;for&quot;, group_types is [&quot;group&quot;, &quot;pop&quot;, &quot;sex&quot;], and combo_fields is [&quot;adj&quot;, &quot;afr&quot;, &quot;female&quot;],</span>
<span class="sd">    this function will return the string &quot; for female samples of African-American/African ancestry&quot;.</span>

<span class="sd">    :param preposition: Relevant preposition to precede automatically generated text.</span>
<span class="sd">    :param combo_dict: Dict with grouping types as keys and values for grouping type as values. This function generates text for these values.</span>
<span class="sd">        Possible grouping types are: &quot;group&quot;, &quot;pop&quot;, &quot;sex&quot;, and &quot;subpop&quot;.</span>
<span class="sd">        Example input: {&quot;pop&quot;: &quot;afr&quot;, &quot;sex&quot;: &quot;female&quot;}</span>
<span class="sd">    :param pop_names: Dict with global population names (keys) and population descriptions (values).</span>
<span class="sd">    :return: String with automatically generated description text for a given set of combo fields.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">header_text</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">preposition</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">combo_dict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">combo_dict</span><span class="p">[</span><span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;adj&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>

    <span class="k">if</span> <span class="s2">&quot;sex&quot;</span> <span class="ow">in</span> <span class="n">combo_dict</span><span class="p">:</span>
        <span class="n">header_text</span> <span class="o">=</span> <span class="n">header_text</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">combo_dict</span><span class="p">[</span><span class="s2">&quot;sex&quot;</span><span class="p">]</span>

    <span class="n">header_text</span> <span class="o">=</span> <span class="n">header_text</span> <span class="o">+</span> <span class="s2">&quot; samples&quot;</span>

    <span class="k">if</span> <span class="s2">&quot;subpop&quot;</span> <span class="ow">in</span> <span class="n">combo_dict</span> <span class="ow">or</span> <span class="s2">&quot;pop&quot;</span> <span class="ow">in</span> <span class="n">combo_dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;subpop&quot;</span> <span class="ow">in</span> <span class="n">combo_dict</span><span class="p">:</span>
            <span class="n">header_text</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">header_text</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; of </span><span class="si">{</span><span class="n">pop_names</span><span class="p">[</span><span class="n">combo_dict</span><span class="p">[</span><span class="s1">&#39;subpop&#39;</span><span class="p">]]</span><span class="si">}</span><span class="s2"> ancestry&quot;</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">header_text</span> <span class="o">=</span> <span class="n">header_text</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; of </span><span class="si">{</span><span class="n">pop_names</span><span class="p">[</span><span class="n">combo_dict</span><span class="p">[</span><span class="s1">&#39;pop&#39;</span><span class="p">]]</span><span class="si">}</span><span class="s2"> ancestry&quot;</span>

    <span class="k">if</span> <span class="s2">&quot;group&quot;</span> <span class="ow">in</span> <span class="n">combo_dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">combo_dict</span><span class="p">[</span><span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;raw&quot;</span><span class="p">:</span>
            <span class="n">header_text</span> <span class="o">=</span> <span class="n">header_text</span> <span class="o">+</span> <span class="s2">&quot;, before removing low-confidence genotypes&quot;</span>

    <span class="k">return</span> <span class="n">header_text</span></div>


<div class="viewcode-block" id="create_label_groups"><a class="viewcode-back" href="../../../api_reference/utils/vcf.html#gnomad.utils.vcf.create_label_groups">[docs]</a><span class="k">def</span> <span class="nf">create_label_groups</span><span class="p">(</span>
    <span class="n">pops</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">sexes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">SEXES</span><span class="p">,</span>
    <span class="n">all_groups</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">GROUPS</span><span class="p">,</span>
    <span class="n">pop_sex_groups</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;adj&quot;</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a list of label group dictionaries needed to populate info dictionary.</span>

<span class="sd">    Label dictionaries are passed as input to `make_info_dict`.</span>

<span class="sd">    :param pops: List of population names.</span>
<span class="sd">    :param sexes: List of sample sexes.</span>
<span class="sd">    :param all_groups: List of data types (raw, adj). Default is `GROUPS`, which is [&quot;raw&quot;, &quot;adj&quot;].</span>
<span class="sd">    :param pop_sex_groups: List of data types (raw, adj) to populate with pops and sexes. Default is [&quot;adj&quot;].</span>
<span class="sd">    :return: List of label group dictionaries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="c1"># This is to capture raw frequency fields, which are</span>
        <span class="c1"># not stratified by sex or population (e.g., only AC_raw exists, not AC_XX_raw)</span>
        <span class="nb">dict</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="n">all_groups</span><span class="p">),</span>
        <span class="nb">dict</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="n">pop_sex_groups</span><span class="p">,</span> <span class="n">sex</span><span class="o">=</span><span class="n">sexes</span><span class="p">),</span>
        <span class="nb">dict</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="n">pop_sex_groups</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="n">pops</span><span class="p">),</span>
        <span class="nb">dict</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="n">pop_sex_groups</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="n">pops</span><span class="p">,</span> <span class="n">sex</span><span class="o">=</span><span class="n">sexes</span><span class="p">),</span>
    <span class="p">]</span></div>


<div class="viewcode-block" id="make_info_dict"><a class="viewcode-back" href="../../../api_reference/utils/vcf.html#gnomad.utils.vcf.make_info_dict">[docs]</a><span class="k">def</span> <span class="nf">make_info_dict</span><span class="p">(</span>
    <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">prefix_before_metric</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">pop_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">POP_NAMES</span><span class="p">,</span>
    <span class="n">label_groups</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">label_delimiter</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="p">,</span>
    <span class="n">bin_edges</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">faf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">popmax</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">description_text</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">age_hist_data</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sort_order</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">SORT_ORDER</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate dictionary of Number and Description attributes of VCF INFO fields.</span>

<span class="sd">    Used to populate the INFO fields of the VCF header during export.</span>

<span class="sd">    Creates:</span>
<span class="sd">        - INFO fields for age histograms (bin freq, n_smaller, and n_larger for heterozygous and homozygous variant carriers)</span>
<span class="sd">        - INFO fields for popmax AC, AN, AF, nhomalt, and popmax population</span>
<span class="sd">        - INFO fields for AC, AN, AF, nhomalt for each combination of sample population, sex, and subpopulation, both for adj and raw data</span>
<span class="sd">        - INFO fields for filtering allele frequency (faf) annotations</span>

<span class="sd">    :param prefix: Prefix string for data, e.g. &quot;gnomAD&quot;. Default is empty string.</span>
<span class="sd">    :param prefix_before_metric: Whether prefix should be added before the metric (AC, AN, AF, nhomalt, faf95, faf99) in INFO field. Default is True.</span>
<span class="sd">    :param pop_names: Dict with global population names (keys) and population descriptions (values). Default is POP_NAMES.</span>
<span class="sd">    :param label_groups: Dictionary containing an entry for each label group, where key is the name of the grouping,</span>
<span class="sd">        e.g. &quot;sex&quot; or &quot;pop&quot;, and value is a list of all possible values for that grouping (e.g. [&quot;male&quot;, &quot;female&quot;] or [&quot;afr&quot;, &quot;nfe&quot;, &quot;amr&quot;]).</span>
<span class="sd">    :param label_delimiter: String to use as delimiter when making group label combinations.</span>
<span class="sd">    :param bin_edges: Dictionary keyed by annotation type, with values that reflect the bin edges corresponding to the annotation.</span>
<span class="sd">    :param faf: If True, use alternate logic to auto-populate dictionary values associated with filter allele frequency annotations.</span>
<span class="sd">    :param popmax: If True, use alternate logic to auto-populate dictionary values associated with popmax annotations.</span>
<span class="sd">    :param description_text: Optional text to append to the end of descriptions. Needs to start with a space if specified.</span>
<span class="sd">    :param str age_hist_data: Pipe-delimited string of age histograms, from `get_age_distributions`.</span>
<span class="sd">    :param sort_order: List containing order to sort label group combinations. Default is SORT_ORDER.</span>
<span class="sd">    :return: Dictionary keyed by VCF INFO annotations, where values are dictionaries of Number and Description attributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">label_delimiter</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="n">info_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">age_hist_data</span><span class="p">:</span>
        <span class="n">age_hist_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">age_hist_het_bin_freq&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Histogram of ages of heterozygous individuals</span><span class="si">{</span><span class="n">description_text</span><span class="si">}</span><span class="s2">; bin edges are: </span><span class="si">{</span><span class="n">bin_edges</span><span class="p">[</span><span class="s1">&#39;het&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">; total number of individuals of any genotype bin: </span><span class="si">{</span><span class="n">age_hist_data</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">age_hist_het_n_smaller&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Count of age values falling below lowest histogram bin edge for heterozygous individuals</span><span class="si">{</span><span class="n">description_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">age_hist_het_n_larger&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Count of age values falling above highest histogram bin edge for heterozygous individuals</span><span class="si">{</span><span class="n">description_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">age_hist_hom_bin_freq&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Histogram of ages of homozygous alternate individuals</span><span class="si">{</span><span class="n">description_text</span><span class="si">}</span><span class="s2">; bin edges are: </span><span class="si">{</span><span class="n">bin_edges</span><span class="p">[</span><span class="s1">&#39;hom&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">; total number of individuals of any genotype bin: </span><span class="si">{</span><span class="n">age_hist_data</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">age_hist_hom_n_smaller&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Count of age values falling below lowest histogram bin edge for homozygous alternate individuals</span><span class="si">{</span><span class="n">description_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">age_hist_hom_n_larger&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Count of age values falling above highest histogram bin edge for homozygous alternate individuals</span><span class="si">{</span><span class="n">description_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">}</span>
        <span class="n">info_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">age_hist_dict</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">popmax</span><span class="p">:</span>
        <span class="n">popmax_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">popmax&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Population with maximum allele frequency</span><span class="si">{</span><span class="n">description_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">AC</span><span class="si">{</span><span class="n">label_delimiter</span><span class="si">}</span><span class="s2">popmax&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Allele count in the population with the maximum allele frequency</span><span class="si">{</span><span class="n">description_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">AN</span><span class="si">{</span><span class="n">label_delimiter</span><span class="si">}</span><span class="s2">popmax&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Total number of alleles in the population with the maximum allele frequency</span><span class="si">{</span><span class="n">description_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">AF</span><span class="si">{</span><span class="n">label_delimiter</span><span class="si">}</span><span class="s2">popmax&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Maximum allele frequency across populations</span><span class="si">{</span><span class="n">description_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">nhomalt</span><span class="si">{</span><span class="n">label_delimiter</span><span class="si">}</span><span class="s2">popmax&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Count of homozygous individuals in the population with the maximum allele frequency</span><span class="si">{</span><span class="n">description_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">faf95</span><span class="si">{</span><span class="n">label_delimiter</span><span class="si">}</span><span class="s2">popmax&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Filtering allele frequency (using Poisson 95% CI) for the population with the maximum allele frequency</span><span class="si">{</span><span class="n">description_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">}</span>
        <span class="n">info_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">popmax_dict</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">group_types</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">label_groups</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">sort_order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">combos</span> <span class="o">=</span> <span class="n">make_label_combos</span><span class="p">(</span><span class="n">label_groups</span><span class="p">,</span> <span class="n">label_delimiter</span><span class="o">=</span><span class="n">label_delimiter</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">combos</span><span class="p">:</span>
            <span class="n">combo_fields</span> <span class="o">=</span> <span class="n">combo</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">label_delimiter</span><span class="p">)</span>
            <span class="n">group_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">group_types</span><span class="p">,</span> <span class="n">combo_fields</span><span class="p">))</span>

            <span class="n">for_combo</span> <span class="o">=</span> <span class="n">make_combo_header_text</span><span class="p">(</span><span class="s2">&quot;for&quot;</span><span class="p">,</span> <span class="n">group_dict</span><span class="p">,</span> <span class="n">pop_names</span><span class="p">)</span>
            <span class="n">in_combo</span> <span class="o">=</span> <span class="n">make_combo_header_text</span><span class="p">(</span><span class="s2">&quot;in&quot;</span><span class="p">,</span> <span class="n">group_dict</span><span class="p">,</span> <span class="n">pop_names</span><span class="p">)</span>

            <span class="n">metrics</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;AC&quot;</span><span class="p">,</span> <span class="s2">&quot;AN&quot;</span><span class="p">,</span> <span class="s2">&quot;AF&quot;</span><span class="p">,</span> <span class="s2">&quot;nhomalt&quot;</span><span class="p">,</span> <span class="s2">&quot;faf95&quot;</span><span class="p">,</span> <span class="s2">&quot;faf99&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">prefix_before_metric</span><span class="p">:</span>
                <span class="n">metric_label_dict</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">metric</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">metric</span><span class="si">}{</span><span class="n">label_delimiter</span><span class="si">}{</span><span class="n">combo</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">metrics</span>
                <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">metric_label_dict</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">metric</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">metric</span><span class="si">}{</span><span class="n">label_delimiter</span><span class="si">}{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">combo</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">metrics</span>
                <span class="p">}</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">faf</span><span class="p">:</span>
                <span class="n">combo_dict</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">metric_label_dict</span><span class="p">[</span><span class="s2">&quot;AC&quot;</span><span class="p">]:</span> <span class="p">{</span>
                        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Alternate allele count</span><span class="si">{</span><span class="n">for_combo</span><span class="si">}{</span><span class="n">description_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">},</span>
                    <span class="n">metric_label_dict</span><span class="p">[</span><span class="s2">&quot;AN&quot;</span><span class="p">]:</span> <span class="p">{</span>
                        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Total number of alleles</span><span class="si">{</span><span class="n">in_combo</span><span class="si">}{</span><span class="n">description_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">},</span>
                    <span class="n">metric_label_dict</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">]:</span> <span class="p">{</span>
                        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Alternate allele frequency</span><span class="si">{</span><span class="n">in_combo</span><span class="si">}{</span><span class="n">description_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">},</span>
                    <span class="n">metric_label_dict</span><span class="p">[</span><span class="s2">&quot;nhomalt&quot;</span><span class="p">]:</span> <span class="p">{</span>
                        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Count of homozygous individuals</span><span class="si">{</span><span class="n">in_combo</span><span class="si">}{</span><span class="n">description_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">},</span>
                <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;XX&quot;</span> <span class="ow">in</span> <span class="n">combo_fields</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="s2">&quot;XY&quot;</span> <span class="ow">in</span> <span class="n">combo_fields</span><span class="p">):</span>
                    <span class="n">faf_description_text</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">description_text</span> <span class="o">+</span> <span class="s2">&quot; in non-PAR regions of sex chromosomes only&quot;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">faf_description_text</span> <span class="o">=</span> <span class="n">description_text</span>
                <span class="n">combo_dict</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">metric_label_dict</span><span class="p">[</span><span class="s2">&quot;faf95&quot;</span><span class="p">]:</span> <span class="p">{</span>
                        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Filtering allele frequency (using Poisson 95% CI)</span><span class="si">{</span><span class="n">for_combo</span><span class="si">}{</span><span class="n">faf_description_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">},</span>
                    <span class="n">metric_label_dict</span><span class="p">[</span><span class="s2">&quot;faf99&quot;</span><span class="p">]:</span> <span class="p">{</span>
                        <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Filtering allele frequency (using Poisson 99% CI)</span><span class="si">{</span><span class="n">for_combo</span><span class="si">}{</span><span class="n">faf_description_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">},</span>
                <span class="p">}</span>
            <span class="n">info_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">combo_dict</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">info_dict</span></div>


<div class="viewcode-block" id="add_as_info_dict"><a class="viewcode-back" href="../../../api_reference/utils/vcf.html#gnomad.utils.vcf.add_as_info_dict">[docs]</a><span class="k">def</span> <span class="nf">add_as_info_dict</span><span class="p">(</span>
    <span class="n">info_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">INFO_DICT</span><span class="p">,</span> <span class="n">as_fields</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">AS_FIELDS</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Update info dictionary with allele-specific terms and their descriptions.</span>

<span class="sd">    Used in VCF export.</span>

<span class="sd">    :param info_dict: Dictionary containing site-level annotations and their descriptions. Default is INFO_DICT.</span>
<span class="sd">    :param as_fields: List containing allele-specific fields to be added to info_dict. Default is AS_FIELDS.</span>
<span class="sd">    :return: Dictionary with allele specific annotations, their descriptions, and their VCF number field.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">as_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">as_fields</span><span class="p">:</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Strip AS_ from field name</span>
            <span class="n">site_field</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>

            <span class="c1"># Get site description from info dictionary and make first letter lower case</span>
            <span class="n">first_letter</span> <span class="o">=</span> <span class="n">info_dict</span><span class="p">[</span><span class="n">site_field</span><span class="p">][</span><span class="s2">&quot;Description&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="n">rest_of_description</span> <span class="o">=</span> <span class="n">info_dict</span><span class="p">[</span><span class="n">site_field</span><span class="p">][</span><span class="s2">&quot;Description&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>

            <span class="n">as_dict</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">as_dict</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s2">&quot;Number&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;A&quot;</span>
            <span class="n">as_dict</span><span class="p">[</span><span class="n">field</span><span class="p">][</span>
                <span class="s2">&quot;Description&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Allele-specific </span><span class="si">{</span><span class="n">first_letter</span><span class="si">}{</span><span class="n">rest_of_description</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not present in input info dictionary!&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">as_dict</span></div>


<div class="viewcode-block" id="make_vcf_filter_dict"><a class="viewcode-back" href="../../../api_reference/utils/vcf.html#gnomad.utils.vcf.make_vcf_filter_dict">[docs]</a><span class="k">def</span> <span class="nf">make_vcf_filter_dict</span><span class="p">(</span>
    <span class="n">snp_cutoff</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">indel_cutoff</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">inbreeding_cutoff</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">variant_qc_filter</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;RF&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate dictionary of Number and Description attributes to be used in the VCF header, specifically for FILTER annotations.</span>

<span class="sd">    Generates descriptions for:</span>
<span class="sd">        - AC0 filter</span>
<span class="sd">        - InbreedingCoeff filter</span>
<span class="sd">        - Variant QC filter (RF or AS_VQSR)</span>
<span class="sd">        - PASS (passed all variant filters)</span>

<span class="sd">    :param snp_cutoff: Minimum SNP cutoff score from random forest model.</span>
<span class="sd">    :param indel_cutoff: Minimum indel cutoff score from random forest model.</span>
<span class="sd">    :param inbreeding_cutoff: Inbreeding coefficient hard cutoff.</span>
<span class="sd">    :param variant_qc_filter: Method used for variant QC filter. One of &#39;RF&#39; or &#39;AS_VQSR&#39;. Default is &#39;RF&#39;.</span>
<span class="sd">    :return: Dictionary keyed by VCF FILTER annotations, where values are Dictionaries of Number and Description attributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">variant_qc_filter_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;RF&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Failed random forest filtering thresholds of </span><span class="si">{</span><span class="n">snp_cutoff</span><span class="si">}</span><span class="s2"> for SNPs and </span><span class="si">{</span><span class="n">indel_cutoff</span><span class="si">}</span><span class="s2"> for indels (probabilities of being a true positive variant)&quot;</span>
        <span class="p">},</span>
        <span class="s2">&quot;AS_VQSR&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Failed VQSR filtering thresholds of </span><span class="si">{</span><span class="n">snp_cutoff</span><span class="si">}</span><span class="s2"> for SNPs and </span><span class="si">{</span><span class="n">indel_cutoff</span><span class="si">}</span><span class="s2"> for indels&quot;</span>
        <span class="p">},</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">variant_qc_filter</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">variant_qc_filter_dict</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">variant_qc_filter</span><span class="si">}</span><span class="s2"> is not a valid value for &#39;variant_qc_filter&#39;. It must be &#39;RF&#39; or &#39;AS_VQSR&#39;&quot;</span>
        <span class="p">)</span>

    <span class="n">filter_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;AC0&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Allele count is zero after filtering out low-confidence genotypes (GQ &lt; 20; DP &lt; 10; and AB &lt; 0.2 for het calls)&quot;</span>
        <span class="p">},</span>
        <span class="s2">&quot;InbreedingCoeff&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;InbreedingCoeff &lt; </span><span class="si">{</span><span class="n">inbreeding_cutoff</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">},</span>
        <span class="s2">&quot;PASS&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="s2">&quot;Passed all variant filters&quot;</span><span class="p">},</span>
        <span class="n">variant_qc_filter</span><span class="p">:</span> <span class="n">variant_qc_filter_dict</span><span class="p">[</span><span class="n">variant_qc_filter</span><span class="p">],</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">filter_dict</span></div>


<div class="viewcode-block" id="make_hist_bin_edges_expr"><a class="viewcode-back" href="../../../api_reference/utils/vcf.html#gnomad.utils.vcf.make_hist_bin_edges_expr">[docs]</a><span class="k">def</span> <span class="nf">make_hist_bin_edges_expr</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">hists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">HISTS</span><span class="p">,</span>
    <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">label_delimiter</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="p">,</span>
    <span class="n">include_age_hists</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create dictionaries containing variant histogram annotations and their associated bin edges, formatted into a string separated by pipe delimiters.</span>

<span class="sd">    :param ht: Table containing histogram variant annotations.</span>
<span class="sd">    :param hists: List of variant histogram annotations. Default is HISTS.</span>
<span class="sd">    :param prefix: Prefix text for age histogram bin edges.  Default is empty string.</span>
<span class="sd">    :param label_delimiter: String used as delimiter between prefix and histogram annotation.</span>
<span class="sd">    :param include_age_hists: Include age histogram annotations.</span>
<span class="sd">    :return: Dictionary keyed by histogram annotation name, with corresponding reformatted bin edges for values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Add underscore to prefix if it isn&#39;t empty</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">+=</span> <span class="n">label_delimiter</span>

    <span class="n">edges_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">include_age_hists</span><span class="p">:</span>
        <span class="n">edges_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">call_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="nb">map</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">ht</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="sa">f</span><span class="s2">&quot;age_hist_</span><span class="si">{</span><span class="n">call_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">collect</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">call_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;het&quot;</span><span class="p">,</span> <span class="s2">&quot;hom&quot;</span><span class="p">]</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">for</span> <span class="n">hist</span> <span class="ow">in</span> <span class="n">hists</span><span class="p">:</span>

        <span class="c1"># Parse hists calculated on both raw and adj-filtered data</span>
        <span class="k">for</span> <span class="n">hist_type</span> <span class="ow">in</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">raw_qual_hists&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">qual_hists&quot;</span><span class="p">]:</span>

            <span class="n">hist_name</span> <span class="o">=</span> <span class="n">hist</span>
            <span class="k">if</span> <span class="s2">&quot;raw&quot;</span> <span class="ow">in</span> <span class="n">hist_type</span><span class="p">:</span>
                <span class="n">hist_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">hist</span><span class="si">}</span><span class="s2">_raw&quot;</span>

            <span class="n">edges_dict</span><span class="p">[</span><span class="n">hist_name</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="nb">map</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="s2">&quot;ab&quot;</span> <span class="ow">in</span> <span class="n">hist</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
                    <span class="n">ht</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="n">hist_type</span><span class="p">][</span><span class="n">hist</span><span class="p">]</span><span class="o">.</span><span class="n">collect</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">edges_dict</span></div>


<div class="viewcode-block" id="make_hist_dict"><a class="viewcode-back" href="../../../api_reference/utils/vcf.html#gnomad.utils.vcf.make_hist_dict">[docs]</a><span class="k">def</span> <span class="nf">make_hist_dict</span><span class="p">(</span>
    <span class="n">bin_edges</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
    <span class="n">adj</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">hist_metric_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">HISTS</span><span class="p">,</span>
    <span class="n">label_delimiter</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate dictionary of Number and Description attributes to be used in the VCF header, specifically for histogram annotations.</span>

<span class="sd">    :param bin_edges: Dictionary keyed by histogram annotation name, with corresponding string-reformatted bin edges for values.</span>
<span class="sd">    :param adj: Whether to create a header dict for raw or adj quality histograms.</span>
<span class="sd">    :param hist_metric_list: List of hists for which to build hist info dict</span>
<span class="sd">    :param label_delimiter: String used as delimiter in values stored in hist_metric_list.</span>
<span class="sd">    :return: Dictionary keyed by VCF INFO annotations, where values are Dictionaries of Number and Description attributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">header_hist_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">hist</span> <span class="ow">in</span> <span class="n">hist_metric_list</span><span class="p">:</span>
        <span class="c1"># Get hists for both raw and adj data</span>
        <span class="c1"># Add &quot;_raw&quot; to quality histograms calculated on raw data</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">adj</span><span class="p">:</span>
            <span class="n">hist</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hist</span><span class="si">}</span><span class="s2">_raw&quot;</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="n">hist</span><span class="p">]</span>
        <span class="n">hist_fields</span> <span class="o">=</span> <span class="n">hist</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">label_delimiter</span><span class="p">)</span>
        <span class="n">hist_text</span> <span class="o">=</span> <span class="n">hist_fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">hist_fields</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;alt&quot;</span><span class="p">:</span>
            <span class="n">hist_text</span> <span class="o">=</span> <span class="n">hist_text</span> <span class="o">+</span> <span class="s2">&quot; in heterozygous individuals&quot;</span>
        <span class="k">if</span> <span class="n">adj</span><span class="p">:</span>
            <span class="n">hist_text</span> <span class="o">=</span> <span class="n">hist_text</span> <span class="o">+</span> <span class="s2">&quot; calculated on high quality genotypes&quot;</span>

        <span class="n">hist_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hist</span><span class="si">}</span><span class="s2">_bin_freq&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Histogram for </span><span class="si">{</span><span class="n">hist_text</span><span class="si">}</span><span class="s2">; bin edges are: </span><span class="si">{</span><span class="n">edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hist</span><span class="si">}</span><span class="s2">_n_smaller&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Count of </span><span class="si">{</span><span class="n">hist_fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2"> values falling below lowest histogram bin edge </span><span class="si">{</span><span class="n">hist_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hist</span><span class="si">}</span><span class="s2">_n_larger&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Description&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Count of </span><span class="si">{</span><span class="n">hist_fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2"> values falling above highest histogram bin edge </span><span class="si">{</span><span class="n">hist_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">}</span>

        <span class="n">header_hist_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">hist_dict</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">header_hist_dict</span></div>


<div class="viewcode-block" id="set_female_y_metrics_to_na"><a class="viewcode-back" href="../../../api_reference/utils/vcf.html#gnomad.utils.vcf.set_female_y_metrics_to_na">[docs]</a><span class="k">def</span> <span class="nf">set_female_y_metrics_to_na</span><span class="p">(</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set AC, AN, and nhomalt chrY variant annotations for females to NA (instead of 0).</span>

<span class="sd">    :param t: Table/MatrixTable containing female variant annotations.</span>
<span class="sd">    :return: Dictionary with reset annotations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metrics</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">row</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
    <span class="n">female_metrics</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">metrics</span> <span class="k">if</span> <span class="s2">&quot;_female&quot;</span> <span class="ow">in</span> <span class="n">x</span> <span class="ow">or</span> <span class="s2">&quot;_XX&quot;</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>

    <span class="n">female_metrics_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">female_metrics</span><span class="p">:</span>
        <span class="n">female_metrics_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
                    <span class="p">(</span><span class="o">~</span><span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_par</span><span class="p">()),</span> <span class="n">t</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">}</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">female_metrics_dict</span></div>


<div class="viewcode-block" id="build_vcf_export_reference"><a class="viewcode-back" href="../../../api_reference/utils/vcf.html#gnomad.utils.vcf.build_vcf_export_reference">[docs]</a><span class="k">def</span> <span class="nf">build_vcf_export_reference</span><span class="p">(</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">build</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;GRCh38&quot;</span><span class="p">,</span>
    <span class="n">keep_contigs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;chr</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">23</span><span class="p">)]</span>
    <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;chrX&quot;</span><span class="p">,</span> <span class="s2">&quot;chrY&quot;</span><span class="p">,</span> <span class="s2">&quot;chrM&quot;</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">ReferenceGenome</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create export reference based on reference genome defined by `build`.</span>

<span class="sd">    By default this will return a new reference with all non-standard contigs eliminated. Keeps chr 1-22, Y, X, and M.</span>

<span class="sd">    An example of a non-standard contig is: ##contig=&lt;ID=chr3_GL000221v1_random,length=155397,assembly=GRCh38&gt;</span>

<span class="sd">    :param name: Name to use for new reference.</span>
<span class="sd">    :param build: Reference genome build to use as starting reference genome.</span>
<span class="sd">    :param keep_contigs: Contigs to keep from reference genome defined by `build`. Default is autosomes, sex chromosomes, and chrM.</span>
<span class="sd">    :return: Reference genome for VCF export containing only contigs in `keep_contigs`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">get_reference</span><span class="p">(</span><span class="n">build</span><span class="p">)</span>

    <span class="n">export_reference</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">ReferenceGenome</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
        <span class="n">contigs</span><span class="o">=</span><span class="n">keep_contigs</span><span class="p">,</span>
        <span class="n">lengths</span><span class="o">=</span><span class="p">{</span><span class="n">contig</span><span class="p">:</span> <span class="n">ref</span><span class="o">.</span><span class="n">lengths</span><span class="p">[</span><span class="n">contig</span><span class="p">]</span> <span class="k">for</span> <span class="n">contig</span> <span class="ow">in</span> <span class="n">keep_contigs</span><span class="p">},</span>
        <span class="n">x_contigs</span><span class="o">=</span><span class="n">ref</span><span class="o">.</span><span class="n">x_contigs</span><span class="p">,</span>
        <span class="n">y_contigs</span><span class="o">=</span><span class="n">ref</span><span class="o">.</span><span class="n">y_contigs</span><span class="p">,</span>
        <span class="n">par</span><span class="o">=</span><span class="p">[</span>
            <span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">contig</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">ref</span><span class="o">.</span><span class="n">par</span>
        <span class="p">],</span>
        <span class="n">mt_contigs</span><span class="o">=</span><span class="n">ref</span><span class="o">.</span><span class="n">mt_contigs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">export_reference</span></div>


<div class="viewcode-block" id="rekey_new_reference"><a class="viewcode-back" href="../../../api_reference/utils/vcf.html#gnomad.utils.vcf.rekey_new_reference">[docs]</a><span class="k">def</span> <span class="nf">rekey_new_reference</span><span class="p">(</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">],</span> <span class="n">reference</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">ReferenceGenome</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Re-key Table or MatrixTable with a new reference genome.</span>

<span class="sd">    :param t: Input Table/MatrixTable.</span>
<span class="sd">    :param reference: Reference genome to re-key with.</span>
<span class="sd">    :return: Re-keyed Table/MatrixTable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;locus&quot;</span><span class="p">:</span> <span class="s2">&quot;locus_original&quot;</span><span class="p">})</span>
    <span class="n">locus_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">locus</span><span class="p">(</span>
        <span class="n">t</span><span class="o">.</span><span class="n">locus_original</span><span class="o">.</span><span class="n">contig</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">locus_original</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">reference_genome</span><span class="o">=</span><span class="n">reference</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate_rows</span><span class="p">(</span><span class="n">locus</span><span class="o">=</span><span class="n">locus_expr</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">key_rows_by</span><span class="p">(</span><span class="s2">&quot;locus&quot;</span><span class="p">,</span> <span class="s2">&quot;alleles&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;locus_original&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">locus</span><span class="o">=</span><span class="n">locus_expr</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;locus&quot;</span><span class="p">,</span> <span class="s2">&quot;alleles&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;locus_original&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">t</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>