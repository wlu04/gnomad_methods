<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gnomad.utils.sparse_mt &mdash; gnomad master documentation</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> gnomad
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resource_sources.html">Resource Sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Change Log</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">gnomad</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>gnomad.utils.sparse_mt</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gnomad.utils.sparse_mt</h1><div class="highlight"><pre>
<span></span><span class="c1"># noqa: D100</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">hail</span> <span class="k">as</span> <span class="nn">hl</span>
<span class="kn">from</span> <span class="nn">gnomad.utils.annotations</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">fs_from_sb</span><span class="p">,</span>
    <span class="n">get_adj_expr</span><span class="p">,</span>
    <span class="n">get_lowqual_expr</span><span class="p">,</span>
    <span class="n">sor_from_sb</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">gnomad.utils.intervals</span> <span class="kn">import</span> <span class="n">interval_length</span><span class="p">,</span> <span class="n">union_intervals</span>
<span class="kn">from</span> <span class="nn">gnomad.utils.reference_genome</span> <span class="kn">import</span> <span class="n">get_reference_genome</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(asctime)s</span><span class="s2"> (</span><span class="si">%(name)s</span><span class="s2"> </span><span class="si">%(lineno)s</span><span class="s2">): </span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">datefmt</span><span class="o">=</span><span class="s2">&quot;%m/</span><span class="si">%d</span><span class="s2">/%Y %I:%M:%S %p&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>

<span class="n">INFO_SUM_AGG_FIELDS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;QUALapprox&quot;</span><span class="p">]</span>
<span class="n">INFO_INT32_SUM_AGG_FIELDS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;VarDP&quot;</span><span class="p">]</span>
<span class="n">INFO_MEDIAN_AGG_FIELDS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ReadPosRankSum&quot;</span><span class="p">,</span> <span class="s2">&quot;MQRankSum&quot;</span><span class="p">]</span>
<span class="n">INFO_ARRAY_SUM_AGG_FIELDS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SB&quot;</span><span class="p">,</span> <span class="s2">&quot;RAW_MQandDP&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="compute_last_ref_block_end"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.compute_last_ref_block_end">[docs]</a><span class="k">def</span> <span class="nf">compute_last_ref_block_end</span><span class="p">(</span><span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the genomic position of the most upstream reference block overlapping each row on a sparse MT.</span>

<span class="sd">    Note that since reference blocks do not extend beyond contig boundaries, only the position is kept.</span>

<span class="sd">    This function returns a Table with that annotation.  (`last_END_position`).</span>

<span class="sd">    :param mt: Input MatrixTable</span>
<span class="sd">    :return: Output Table with `last_END_position` annotation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">select_entries</span><span class="p">(</span><span class="s2">&quot;END&quot;</span><span class="p">)</span>

    <span class="c1"># Localize entries, so that they can be viewed as an array and scanned over using hl.scan.array_agg</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">_localize_entries</span><span class="p">(</span><span class="s2">&quot;__entries&quot;</span><span class="p">,</span> <span class="s2">&quot;__cols&quot;</span><span class="p">)</span>

    <span class="c1"># Compute the position by using hl.scan._prev_nonnull.</span>
    <span class="c1"># This was inspired by hl.experimental.densify</span>
    <span class="c1"># _prev_non_null is an aggregator that keeps the previous record in memory</span>
    <span class="c1"># and updates it with the given value at the row if it&#39;s not null (missing)</span>
    <span class="c1"># The following code computes the following annotation for each row:</span>
    <span class="c1"># 1. Keep a scan of the entries using _prev_nonnull, keeping the start (ht.locus) and end (entry.END) of each ref block  (1.1)</span>
    <span class="c1"># 2. For the current row locus, record the start of the block that starts the furthest away,</span>
    <span class="c1">#    that is the minimum position in the current scan for any block that overlaps the current locus (2.1)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
        <span class="n">last_END_position</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>  <span class="c1"># 2. For the current row locus, record the start of the block that starts the furthest away</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">entry</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">_prev_nonnull</span><span class="p">(</span>  <span class="c1"># 1. Keep a scan of the entries using _prev_nonnull</span>
                        <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
                            <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span>
                                <span class="n">entry</span><span class="o">.</span><span class="n">END</span>
                            <span class="p">),</span>  <span class="c1"># Update the scan whenever a new ref block is encountered</span>
                            <span class="n">hl</span><span class="o">.</span><span class="n">tuple</span><span class="p">(</span>
                                <span class="p">[</span>  <span class="c1"># 1.1 keep the start (ht.locus) and end (entry.END) of each ref block</span>
                                    <span class="n">ht</span><span class="o">.</span><span class="n">locus</span><span class="p">,</span>
                                    <span class="n">entry</span><span class="o">.</span><span class="n">END</span><span class="p">,</span>
                                <span class="p">]</span>
                            <span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">),</span>
                    <span class="n">ht</span><span class="o">.</span><span class="n">__entries</span><span class="p">,</span>
                <span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>  <span class="c1"># 2.1 get the start position of blocks that overlap the current locus</span>
                        <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">position</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">contig</span> <span class="o">==</span> <span class="n">ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">contig</span><span class="p">),</span>
                        <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="p">),</span>
            <span class="n">ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">select_globals</span><span class="p">()</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;locus&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="densify_sites"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.densify_sites">[docs]</a><span class="k">def</span> <span class="nf">densify_sites</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">sites_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">last_END_positions_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">semi_join_rows</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a dense version of the input sparse MT at the sites in `sites_ht` reading the minimal amount of data required.</span>

<span class="sd">    Note that only rows that appear both in `mt` and `sites_ht` are returned.</span>

<span class="sd">    :param mt: Input sparse MT</span>
<span class="sd">    :param sites_ht: Desired sites to densify</span>
<span class="sd">    :param last_END_positions_ht: Table storing positions of the furthest ref block (END tag)</span>
<span class="sd">    :param semi_join_rows: Whether to filter the MT rows based on semi-join (default, better if sites_ht is large) or based on filter_intervals (better if sites_ht only contains a few sites)</span>
<span class="sd">    :return: Dense MT filtered to the sites in `sites_ht`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing intervals to densify from sites Table.&quot;</span><span class="p">)</span>
    <span class="n">sites_ht</span> <span class="o">=</span> <span class="n">sites_ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;locus&quot;</span><span class="p">)</span>
    <span class="n">sites_ht</span> <span class="o">=</span> <span class="n">sites_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">interval</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">locus_interval</span><span class="p">(</span>
            <span class="n">sites_ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">contig</span><span class="p">,</span>
            <span class="n">last_END_positions_ht</span><span class="p">[</span><span class="n">sites_ht</span><span class="o">.</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">last_END_position</span><span class="p">,</span>
            <span class="n">end</span><span class="o">=</span><span class="n">sites_ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
            <span class="n">includes_end</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">reference_genome</span><span class="o">=</span><span class="n">sites_ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">reference_genome</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">sites_ht</span> <span class="o">=</span> <span class="n">sites_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">sites_ht</span><span class="o">.</span><span class="n">interval</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">semi_join_rows</span><span class="p">:</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">sites_ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;interval&quot;</span><span class="p">)[</span><span class="n">mt</span><span class="o">.</span><span class="n">locus</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Collecting intervals to densify.&quot;</span><span class="p">)</span>
        <span class="n">intervals</span> <span class="o">=</span> <span class="n">sites_ht</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Found </span><span class="si">{0}</span><span class="s2"> intervals, totalling </span><span class="si">{1}</span><span class="s2"> bp in the dense Matrix.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">intervals</span><span class="p">),</span>
                <span class="nb">sum</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">interval_length</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">union_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
                    <span class="p">]</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="n">mt</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">filter_intervals</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">intervals</span><span class="p">)</span>

    <span class="n">mt</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">densify</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">sites_ht</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">locus</span><span class="p">]))</span></div>


<span class="k">def</span> <span class="nf">_get_info_agg_expr</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_SUM_AGG_FIELDS</span><span class="p">,</span>
    <span class="n">int32_sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_INT32_SUM_AGG_FIELDS</span><span class="p">,</span>
    <span class="n">median_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_MEDIAN_AGG_FIELDS</span><span class="p">,</span>
    <span class="n">array_sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_ARRAY_SUM_AGG_FIELDS</span><span class="p">,</span>
    <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Aggregation</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create Aggregators for both site or AS info expression aggregations.</span>

<span class="sd">    .. note::</span>

<span class="sd">        - If `SB` is specified in array_sum_agg_fields, it will be aggregated as `AS_SB_TABLE`, according to GATK standard nomenclature.</span>
<span class="sd">        - If `RAW_MQandDP` is specified in array_sum_agg_fields, it will be used for the `MQ` calculation and then dropped according to GATK recommendation.</span>
<span class="sd">        - If `RAW_MQ` and `MQ_DP` are given, they will be used for the `MQ` calculation and then dropped according to GATK recommendation.</span>
<span class="sd">        - If the fields to be aggregate (`sum_agg_fields`, `int32_sum_agg_fields`, `median_agg_fields`) are passed as</span>
<span class="sd">          list of str, then they should correspond to entry fields in `mt` or in `mt.gvcf_info`.</span>
<span class="sd">        - Priority is given to entry fields in `mt` over those in `mt.gvcf_info` in case of a name clash.</span>

<span class="sd">    :param mt: Input MT</span>
<span class="sd">    :param sum_agg_fields: Fields to aggregate using sum.</span>
<span class="sd">    :param int32_sum_agg_fields: Fields to aggregate using sum using int32.</span>
<span class="sd">    :param median_agg_fields: Fields to aggregate using (approximate) median.</span>
<span class="sd">    :param median_agg_fields: Fields to aggregate using element-wise summing over an array.</span>
<span class="sd">    :param prefix: Optional prefix for the fields. Used for adding &#39;AS_&#39; in the AS case.</span>

<span class="sd">    :return: Dictionary of expression names and their corresponding aggregation Expression</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_agg_list_to_dict</span><span class="p">(</span>
        <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">fields</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]:</span>
        <span class="n">out_fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s2">&quot;gvcf_info&quot;</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">entry</span><span class="p">:</span>
            <span class="n">out_fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">mt</span><span class="o">.</span><span class="n">gvcf_info</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">gvcf_info</span><span class="p">}</span>

        <span class="n">out_fields</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">f</span><span class="p">:</span> <span class="n">mt</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">entry</span><span class="p">})</span>

        <span class="c1"># Check that all fields were found</span>
        <span class="n">missing_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">out_fields</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">missing_fields</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Could not find the following field(s)in the MT entry schema (or nested under mt.gvcf_info: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing_fields</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">out_fields</span>

    <span class="c1"># Map str to expressions where needed</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sum_agg_fields</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">sum_agg_fields</span> <span class="o">=</span> <span class="n">_agg_list_to_dict</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">sum_agg_fields</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">int32_sum_agg_fields</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">int32_sum_agg_fields</span> <span class="o">=</span> <span class="n">_agg_list_to_dict</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">int32_sum_agg_fields</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">median_agg_fields</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">median_agg_fields</span> <span class="o">=</span> <span class="n">_agg_list_to_dict</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">median_agg_fields</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array_sum_agg_fields</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">array_sum_agg_fields</span> <span class="o">=</span> <span class="n">_agg_list_to_dict</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">array_sum_agg_fields</span><span class="p">)</span>

    <span class="c1"># Create aggregators</span>
    <span class="n">agg_expr</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">agg_expr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">approx_quantiles</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">median_agg_fields</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="n">agg_expr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">sum_agg_fields</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="p">)</span>
    <span class="n">agg_expr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">int32_sum_agg_fields</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="n">agg_expr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">expr</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">array_sum_agg_fields</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">)</span>

    <span class="c1"># Handle annotations combinations and casting for specific annotations</span>

    <span class="c1"># If RAW_MQandDP is in agg_expr or if both MQ_DP and RAW_MQ are, compute MQ instead</span>
    <span class="n">mq_tuple</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">RAW_MQandDP&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Computing </span><span class="si">%s</span><span class="s2">MQ as sqrt(</span><span class="si">%s</span><span class="s2">RAW_MQandDP[0]/</span><span class="si">%s</span><span class="s2">RAW_MQandDP[1]). &quot;</span>
            <span class="s2">&quot;Note that </span><span class="si">%s</span><span class="s2">MQ will be set to 0 if </span><span class="si">%s</span><span class="s2">RAW_MQandDP[1] == 0.&quot;</span><span class="p">,</span>
            <span class="o">*</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">mq_tuple</span> <span class="o">=</span> <span class="n">agg_expr</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">RAW_MQandDP&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">RAW_MQ&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span> <span class="ow">and</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">MQ_DP&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Computing </span><span class="si">%s</span><span class="s2">MQ as sqrt(</span><span class="si">%s</span><span class="s2">RAW_MQ/</span><span class="si">%s</span><span class="s2">MQ_DP). &quot;</span>
            <span class="s2">&quot;Note that MQ will be set to 0 if </span><span class="si">%s</span><span class="s2">RAW_MQ == 0.&quot;</span><span class="p">,</span>
            <span class="o">*</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">mq_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">agg_expr</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">RAW_MQ&quot;</span><span class="p">),</span> <span class="n">agg_expr</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">MQ_DP&quot;</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">mq_tuple</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">MQ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
            <span class="n">mq_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mq_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">mq_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">0</span>
        <span class="p">)</span>

    <span class="c1"># If both VarDP and QUALapprox are present, also compute QD.</span>
    <span class="k">if</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">VarDP&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span> <span class="ow">and</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">QUALapprox&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Computing </span><span class="si">%s</span><span class="s2">QD as </span><span class="si">%s</span><span class="s2">QUALapprox/</span><span class="si">%s</span><span class="s2">VarDP. &quot;</span>
            <span class="s2">&quot;Note that </span><span class="si">%s</span><span class="s2">QD will be set to 0 if </span><span class="si">%s</span><span class="s2">VarDP == 0.&quot;</span><span class="p">,</span>
            <span class="o">*</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">var_dp</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">int32_sum_agg_fields</span><span class="p">[</span><span class="s2">&quot;VarDP&quot;</span><span class="p">]))</span>
        <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">QD&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
            <span class="n">var_dp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">QUALapprox&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">var_dp</span><span class="p">,</span> <span class="mi">0</span>
        <span class="p">)</span>

    <span class="c1"># SB needs to be cast to int32 for FS down the line</span>
    <span class="k">if</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">SB&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">SB&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">SB&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">agg_expr</span>


<div class="viewcode-block" id="get_as_info_expr"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.get_as_info_expr">[docs]</a><span class="k">def</span> <span class="nf">get_as_info_expr</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_SUM_AGG_FIELDS</span><span class="p">,</span>
    <span class="n">int32_sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_INT32_SUM_AGG_FIELDS</span><span class="p">,</span>
    <span class="n">median_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_MEDIAN_AGG_FIELDS</span><span class="p">,</span>
    <span class="n">array_sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_ARRAY_SUM_AGG_FIELDS</span><span class="p">,</span>
    <span class="n">alt_alleles_range_array_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;alt_alleles_range_array&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an allele-specific annotation Struct containing typical VCF INFO fields from GVCF INFO fields stored in the MT entries.</span>

<span class="sd">    .. note::</span>

<span class="sd">        - If `SB` is specified in array_sum_agg_fields, it will be aggregated as `AS_SB_TABLE`, according to GATK standard nomenclature.</span>
<span class="sd">        - If `RAW_MQandDP` is specified in array_sum_agg_fields, it will be used for the `MQ` calculation and then dropped according to GATK recommendation.</span>
<span class="sd">        - If `RAW_MQ` and `MQ_DP` are given, they will be used for the `MQ` calculation and then dropped according to GATK recommendation.</span>
<span class="sd">        - If the fields to be aggregate (`sum_agg_fields`, `int32_sum_agg_fields`, `median_agg_fields`) are passed as list of str,</span>
<span class="sd">          then they should correspond to entry fields in `mt` or in `mt.gvcf_info`.</span>
<span class="sd">        - Priority is given to entry fields in `mt` over those in `mt.gvcf_info` in case of a name clash.</span>

<span class="sd">    :param mt: Input Matrix Table</span>
<span class="sd">    :param sum_agg_fields: Fields to aggregate using sum.</span>
<span class="sd">    :param int32_sum_agg_fields: Fields to aggregate using sum using int32.</span>
<span class="sd">    :param median_agg_fields: Fields to aggregate using (approximate) median.</span>
<span class="sd">    :param array_sum_agg_fields: Fields to aggregate using array sum.</span>
<span class="sd">    :param alt_alleles_range_array_field: Annotation containing an array of the range of alternate alleles e.g., `hl.range(1, hl.len(mt.alleles))`</span>
<span class="sd">    :return: Expression containing the AS info fields</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;DP&quot;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sum_agg_fields</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">int32_sum_agg_fields</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;`DP` was included in allele-specific aggregation, &quot;</span>
            <span class="s2">&quot;however `DP` is typically not aggregated by allele; `VarDP` is.&quot;</span>
            <span class="s2">&quot;Note that the resulting `AS_DP` field will NOT include reference genotypes.&quot;</span>
        <span class="p">)</span>

    <span class="n">agg_expr</span> <span class="o">=</span> <span class="n">_get_info_agg_expr</span><span class="p">(</span>
        <span class="n">mt</span><span class="o">=</span><span class="n">mt</span><span class="p">,</span>
        <span class="n">sum_agg_fields</span><span class="o">=</span><span class="n">sum_agg_fields</span><span class="p">,</span>
        <span class="n">int32_sum_agg_fields</span><span class="o">=</span><span class="n">int32_sum_agg_fields</span><span class="p">,</span>
        <span class="n">median_agg_fields</span><span class="o">=</span><span class="n">median_agg_fields</span><span class="p">,</span>
        <span class="n">array_sum_agg_fields</span><span class="o">=</span><span class="n">array_sum_agg_fields</span><span class="p">,</span>
        <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;AS_&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Rename AS_SB to AS_SB_TABLE if present</span>
    <span class="k">if</span> <span class="s2">&quot;AS_SB&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">agg_expr</span><span class="p">[</span><span class="s2">&quot;AS_SB_TABLE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">agg_expr</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;AS_SB&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">alt_alleles_range_array_field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">row</span> <span class="ow">or</span> <span class="n">mt</span><span class="p">[</span>
        <span class="n">alt_alleles_range_array_field</span>
    <span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">hl</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;array&lt;int32&gt;&quot;</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&#39;get_as_info_expr&#39; expected a row field &#39;</span><span class="si">{</span><span class="n">alt_alleles_range_array_field</span><span class="si">}</span><span class="s2">&#39; of type array&lt;int32&gt;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># Modify aggregations to aggregate per allele</span>
    <span class="n">agg_expr</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">LA</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">ai</span><span class="p">),</span> <span class="n">expr</span><span class="p">),</span>
            <span class="n">mt</span><span class="p">[</span><span class="n">alt_alleles_range_array_field</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="c1"># Run aggregations</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">agg_expr</span><span class="p">)</span>

    <span class="c1"># Add SB Ax2 aggregation logic and FS if SB is present</span>
    <span class="k">if</span> <span class="s2">&quot;AS_SB_TABLE&quot;</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
        <span class="n">as_sb_table</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">info</span><span class="o">.</span><span class="n">AS_SB_TABLE</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">i</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">j</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>  <span class="c1"># ref</span>
            <span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="n">info</span><span class="o">.</span><span class="n">AS_SB_TABLE</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>  <span class="c1"># each alt</span>
        <span class="p">)</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">AS_SB_TABLE</span><span class="o">=</span><span class="n">as_sb_table</span><span class="p">,</span>
            <span class="n">AS_FS</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">alleles</span><span class="p">))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">fs_from_sb</span><span class="p">(</span><span class="n">as_sb_table</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">as_sb_table</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="p">),</span>
            <span class="n">AS_SOR</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">alleles</span><span class="p">))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">sor_from_sb</span><span class="p">(</span><span class="n">as_sb_table</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">as_sb_table</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="p">),</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">info</span></div>


<div class="viewcode-block" id="get_site_info_expr"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.get_site_info_expr">[docs]</a><span class="k">def</span> <span class="nf">get_site_info_expr</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_SUM_AGG_FIELDS</span><span class="p">,</span>
    <span class="n">int32_sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_INT32_SUM_AGG_FIELDS</span><span class="p">,</span>
    <span class="n">median_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_MEDIAN_AGG_FIELDS</span><span class="p">,</span>
    <span class="n">array_sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_ARRAY_SUM_AGG_FIELDS</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a site-level annotation Struct aggregating typical VCF INFO fields from GVCF INFO fields stored in the MT entries.</span>

<span class="sd">    .. note::</span>

<span class="sd">        - If `RAW_MQandDP` is specified in array_sum_agg_fields, it will be used for the `MQ` calculation and then dropped according to GATK recommendation.</span>
<span class="sd">        - If `RAW_MQ` and `MQ_DP` are given, they will be used for the `MQ` calculation and then dropped according to GATK recommendation.</span>
<span class="sd">        - If the fields to be aggregate (`sum_agg_fields`, `int32_sum_agg_fields`, `median_agg_fields`) are passed as</span>
<span class="sd">          list of str, then they should correspond to entry fields in `mt` or in `mt.gvcf_info`.</span>
<span class="sd">        - Priority is given to entry fields in `mt` over those in `mt.gvcf_info` in case of a name clash.</span>

<span class="sd">    :param mt: Input Matrix Table</span>
<span class="sd">    :param sum_agg_fields: Fields to aggregate using sum.</span>
<span class="sd">    :param int32_sum_agg_fields: Fields to aggregate using sum using int32.</span>
<span class="sd">    :param median_agg_fields: Fields to aggregate using (approximate) median.</span>
<span class="sd">    :return: Expression containing the site-level info fields</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;DP&quot;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sum_agg_fields</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">int32_sum_agg_fields</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;`DP` was included in site-level aggregation. This requires a densifying prior to running get_site_info_expr&quot;</span>
        <span class="p">)</span>

    <span class="n">agg_expr</span> <span class="o">=</span> <span class="n">_get_info_agg_expr</span><span class="p">(</span>
        <span class="n">mt</span><span class="o">=</span><span class="n">mt</span><span class="p">,</span>
        <span class="n">sum_agg_fields</span><span class="o">=</span><span class="n">sum_agg_fields</span><span class="p">,</span>
        <span class="n">int32_sum_agg_fields</span><span class="o">=</span><span class="n">int32_sum_agg_fields</span><span class="p">,</span>
        <span class="n">median_agg_fields</span><span class="o">=</span><span class="n">median_agg_fields</span><span class="p">,</span>
        <span class="n">array_sum_agg_fields</span><span class="o">=</span><span class="n">array_sum_agg_fields</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Add FS and SOR if SB is present</span>
    <span class="c1"># This is done outside of _get_info_agg_expr as the behavior is different in site vs allele-specific versions</span>
    <span class="k">if</span> <span class="s2">&quot;SB&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">agg_expr</span><span class="p">[</span><span class="s2">&quot;FS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fs_from_sb</span><span class="p">(</span><span class="n">agg_expr</span><span class="p">[</span><span class="s2">&quot;SB&quot;</span><span class="p">])</span>
        <span class="n">agg_expr</span><span class="p">[</span><span class="s2">&quot;SOR&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sor_from_sb</span><span class="p">(</span><span class="n">agg_expr</span><span class="p">[</span><span class="s2">&quot;SB&quot;</span><span class="p">])</span>

    <span class="c1"># Run aggregator on non-ref genotypes</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="n">mt</span><span class="o">.</span><span class="n">LGT</span><span class="o">.</span><span class="n">is_non_ref</span><span class="p">(),</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;DP&quot;</span><span class="p">}),</span>
    <span class="p">)</span>

    <span class="c1"># Add DP, computed over both ref and non-ref genotypes, if present</span>
    <span class="k">if</span> <span class="s2">&quot;DP&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">DP</span><span class="o">=</span><span class="n">agg_expr</span><span class="p">[</span><span class="s2">&quot;DP&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">info</span></div>


<div class="viewcode-block" id="default_compute_info"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.default_compute_info">[docs]</a><span class="k">def</span> <span class="nf">default_compute_info</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">site_annotations</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">n_partitions</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5000</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute a HT with the typical GATK allele-specific (AS) info fields as well as ACs and lowqual fields.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This table doesn&#39;t split multi-allelic sites.</span>

<span class="sd">    :param mt: Input MatrixTable. Note that this table should be filtered to nonref sites.</span>
<span class="sd">    :param site_annotations: Whether to also generate site level info fields. Default is False.</span>
<span class="sd">    :param n_partitions: Number of desired partitions for output Table. Default is 5000.</span>
<span class="sd">    :return: Table with info fields</span>
<span class="sd">    :rtype: Table</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Move gvcf info entries out from nested struct</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">transmute_entries</span><span class="p">(</span><span class="o">**</span><span class="n">mt</span><span class="o">.</span><span class="n">gvcf_info</span><span class="p">)</span>

    <span class="c1"># Adding alt_alleles_range_array as a required annotation for get_as_info_expr to reduce memory usage</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_rows</span><span class="p">(</span><span class="n">alt_alleles_range_array</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">alleles</span><span class="p">)))</span>

    <span class="c1"># Compute AS info expr</span>
    <span class="n">info_expr</span> <span class="o">=</span> <span class="n">get_as_info_expr</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">site_annotations</span><span class="p">:</span>
        <span class="n">info_expr</span> <span class="o">=</span> <span class="n">info_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">get_site_info_expr</span><span class="p">(</span><span class="n">mt</span><span class="p">))</span>

    <span class="c1"># Add AC and AC_raw:</span>
    <span class="c1"># First compute ACs for each non-ref allele, grouped by adj</span>
    <span class="n">grp_ac_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">mt</span><span class="o">.</span><span class="n">LA</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">ai</span><span class="p">),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span>
                <span class="n">get_adj_expr</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">LGT</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">GQ</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">DP</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">LAD</span><span class="p">),</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">mt</span><span class="o">.</span><span class="n">LGT</span><span class="o">.</span><span class="n">one_hot_alleles</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">LA</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">x</span><span class="p">)))[</span>
                        <span class="n">mt</span><span class="o">.</span><span class="n">LA</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
                    <span class="p">]</span>
                <span class="p">),</span>
            <span class="p">),</span>
        <span class="p">),</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">alleles</span><span class="p">)),</span>
    <span class="p">)</span>

    <span class="c1"># Then, for each non-ref allele, compute</span>
    <span class="c1"># AC as the adj group</span>
    <span class="c1"># AC_raw as the sum of adj and non-adj groups</span>
    <span class="n">info_expr</span> <span class="o">=</span> <span class="n">info_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">AC_raw</span><span class="o">=</span><span class="n">grp_ac_expr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">))),</span>
        <span class="n">AC</span><span class="o">=</span><span class="n">grp_ac_expr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="mi">0</span><span class="p">))),</span>
    <span class="p">)</span>

    <span class="n">info_ht</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">select_rows</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="n">info_expr</span><span class="p">)</span><span class="o">.</span><span class="n">rows</span><span class="p">()</span>

    <span class="c1"># Add AS lowqual flag</span>
    <span class="n">info_ht</span> <span class="o">=</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">AS_lowqual</span><span class="o">=</span><span class="n">get_lowqual_expr</span><span class="p">(</span><span class="n">info_ht</span><span class="o">.</span><span class="n">alleles</span><span class="p">,</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">AS_QUALapprox</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">site_annotations</span><span class="p">:</span>
        <span class="c1"># Add lowqual flag</span>
        <span class="n">info_ht</span> <span class="o">=</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">lowqual</span><span class="o">=</span><span class="n">get_lowqual_expr</span><span class="p">(</span><span class="n">info_ht</span><span class="o">.</span><span class="n">alleles</span><span class="p">,</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">QUALapprox</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">naive_coalesce</span><span class="p">(</span><span class="n">n_partitions</span><span class="p">)</span></div>


<div class="viewcode-block" id="split_info_annotation"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.split_info_annotation">[docs]</a><span class="k">def</span> <span class="nf">split_info_annotation</span><span class="p">(</span>
    <span class="n">info_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">,</span> <span class="n">a_index</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split multi-allelic allele-specific info fields.</span>

<span class="sd">    :param info_expr: Field containing info struct.</span>
<span class="sd">    :param a_index: Allele index. Output by hl.split_multi or hl.split_multi_hts.</span>
<span class="sd">    :return: Info struct with split annotations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Index AS annotations</span>
    <span class="n">info_expr</span> <span class="o">=</span> <span class="n">info_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="n">f</span><span class="p">:</span> <span class="n">info_expr</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">a_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">info_expr</span>
            <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;AC&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;AS_&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">f</span> <span class="o">==</span> <span class="s2">&quot;AS_SB_TABLE&quot;</span><span class="p">)</span>
        <span class="p">},</span>
        <span class="n">AS_SB_TABLE</span><span class="o">=</span><span class="n">info_expr</span><span class="o">.</span><span class="n">AS_SB_TABLE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">info_expr</span><span class="o">.</span><span class="n">AS_SB_TABLE</span><span class="p">[</span><span class="n">a_index</span><span class="p">]),</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">info_expr</span></div>


<div class="viewcode-block" id="split_lowqual_annotation"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.split_lowqual_annotation">[docs]</a><span class="k">def</span> <span class="nf">split_lowqual_annotation</span><span class="p">(</span>
    <span class="n">lowqual_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span> <span class="n">a_index</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split multi-allelic low QUAL annotation.</span>

<span class="sd">    :param lowqual_expr: Field containing low QUAL annotation.</span>
<span class="sd">    :param a_index: Allele index. Output by hl.split_multi or hl.split_multi_hts.</span>
<span class="sd">    :return: Low QUAL expression for particular allele.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">lowqual_expr</span><span class="p">[</span><span class="n">a_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="impute_sex_ploidy"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.impute_sex_ploidy">[docs]</a><span class="k">def</span> <span class="nf">impute_sex_ploidy</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">excluded_calling_intervals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">included_calling_intervals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">normalization_contig</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;chr20&quot;</span><span class="p">,</span>
    <span class="n">chr_x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">chr_y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Impute sex ploidy from a sparse MatrixTable.</span>

<span class="sd">    Sex ploidy is imputed by normalizing the coverage of chromosomes X and Y using the coverage of an autosomal</span>
<span class="sd">    chromosome (by default chr20).</span>

<span class="sd">    Coverage is computed using the median block coverage (summed over the block size) and the non-ref coverage at</span>
<span class="sd">    non-ref genotypes.</span>

<span class="sd">    :param mt: Input sparse Matrix Table</span>
<span class="sd">    :param excluded_calling_intervals: Optional table of intervals to exclude from the computation.</span>
<span class="sd">        Used only when determining contig size (not used when computing chromosome depth).</span>
<span class="sd">    :param included_calling_intervals: Optional table of intervals to use in the computation.</span>
<span class="sd">        Used only when determining contig size (not used when computing chromosome depth).</span>
<span class="sd">    :param normalization_contig: Which chromosome to normalize by</span>
<span class="sd">    :param chr_x: Optional X Chromosome contig name (by default uses the X contig in the reference)</span>
<span class="sd">    :param chr_y: Optional Y Chromosome contig name (by default uses the Y contig in the reference)</span>
<span class="sd">    :return: Table with mean coverage over chromosomes 20, X and Y and sex chromosomes ploidy based on normalized coverage.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">get_reference_genome</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">locus</span><span class="p">,</span> <span class="n">add_sequence</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">chr_x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">x_contigs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Found </span><span class="si">{0}</span><span class="s2"> X chromosome contigs (</span><span class="si">{1}</span><span class="s2">) in Genome reference. sparse_impute_sex_ploidy currently only supports a single X chromosome contig. Please use the `chr_x` argument to  specify which X chromosome contig to use &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">x_contigs</span><span class="p">),</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">x_contigs</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">chr_x</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">x_contigs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">chr_y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">y_contigs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Found </span><span class="si">{0}</span><span class="s2"> Y chromosome contigs (</span><span class="si">{1}</span><span class="s2">) in Genome reference. sparse_impute_sex_ploidy currently only supports a single Y chromosome contig. Please use the `chr_y` argument to  specify which Y chromosome contig to use &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">y_contigs</span><span class="p">),</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">y_contigs</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">chr_y</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">y_contigs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_contig_size</span><span class="p">(</span><span class="n">contig</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Working on </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">contig</span><span class="p">)</span>
        <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">range_table</span><span class="p">(</span>
            <span class="n">ref</span><span class="o">.</span><span class="n">contig_length</span><span class="p">(</span><span class="n">contig</span><span class="p">),</span>
            <span class="n">n_partitions</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">contig_length</span><span class="p">(</span><span class="n">contig</span><span class="p">)</span> <span class="o">/</span> <span class="mi">500_000</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">locus</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">locus</span><span class="p">(</span><span class="n">contig</span><span class="o">=</span><span class="n">contig</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">contig_ht</span><span class="o">.</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">reference_genome</span><span class="o">=</span><span class="n">ref</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">contig_ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">sequence_context</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;n&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">contig</span> <span class="ow">in</span> <span class="n">ref</span><span class="o">.</span><span class="n">x_contigs</span><span class="p">:</span>
            <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">contig_ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">contig</span> <span class="ow">in</span> <span class="n">ref</span><span class="o">.</span><span class="n">y_contigs</span><span class="p">:</span>
            <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">contig_ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">())</span>

        <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;locus&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">included_calling_intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">included_calling_intervals</span><span class="p">[</span><span class="n">contig_ht</span><span class="o">.</span><span class="n">key</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">excluded_calling_intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">is_missing</span><span class="p">(</span><span class="n">excluded_calling_intervals</span><span class="p">[</span><span class="n">contig_ht</span><span class="o">.</span><span class="n">key</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="n">contig_size</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Contig </span><span class="si">%s</span><span class="s2"> has </span><span class="si">%d</span><span class="s2"> bases for coverage.&quot;</span><span class="p">,</span> <span class="n">contig</span><span class="p">,</span> <span class="n">contig_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">contig_size</span>

    <span class="k">def</span> <span class="nf">get_chr_dp_ann</span><span class="p">(</span><span class="n">chrom</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
        <span class="n">contig_size</span> <span class="o">=</span> <span class="n">get_contig_size</span><span class="p">(</span><span class="n">chrom</span><span class="p">)</span>
        <span class="n">chr_mt</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">filter_intervals</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">parse_locus_interval</span><span class="p">(</span><span class="n">chrom</span><span class="p">)])</span>

        <span class="k">if</span> <span class="n">chrom</span> <span class="ow">in</span> <span class="n">ref</span><span class="o">.</span><span class="n">x_contigs</span><span class="p">:</span>
            <span class="n">chr_mt</span> <span class="o">=</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span><span class="n">chr_mt</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">chrom</span> <span class="ow">in</span> <span class="n">ref</span><span class="o">.</span><span class="n">y_contigs</span><span class="p">:</span>
            <span class="n">chr_mt</span> <span class="o">=</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span><span class="n">chr_mt</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">select_cols</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">_mean_dp&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
                        <span class="n">chr_mt</span><span class="o">.</span><span class="n">LGT</span><span class="o">.</span><span class="n">is_hom_ref</span><span class="p">(),</span>
                        <span class="n">chr_mt</span><span class="o">.</span><span class="n">DP</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">END</span> <span class="o">-</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">position</span><span class="p">),</span>
                        <span class="n">chr_mt</span><span class="o">.</span><span class="n">DP</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="o">/</span> <span class="n">contig_size</span>
            <span class="p">}</span>
        <span class="p">)</span><span class="o">.</span><span class="n">cols</span><span class="p">()</span>

    <span class="n">normalization_chrom_dp</span> <span class="o">=</span> <span class="n">get_chr_dp_ann</span><span class="p">(</span><span class="n">normalization_contig</span><span class="p">)</span>
    <span class="n">chrX_dp</span> <span class="o">=</span> <span class="n">get_chr_dp_ann</span><span class="p">(</span><span class="n">chr_x</span><span class="p">)</span>
    <span class="n">chrY_dp</span> <span class="o">=</span> <span class="n">get_chr_dp_ann</span><span class="p">(</span><span class="n">chr_y</span><span class="p">)</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="n">normalization_chrom_dp</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="o">**</span><span class="n">chrX_dp</span><span class="p">[</span><span class="n">normalization_chrom_dp</span><span class="o">.</span><span class="n">key</span><span class="p">],</span> <span class="o">**</span><span class="n">chrY_dp</span><span class="p">[</span><span class="n">normalization_chrom_dp</span><span class="o">.</span><span class="n">key</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">chr_x</span><span class="si">}</span><span class="s2">_ploidy&quot;</span><span class="p">:</span> <span class="n">ht</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">chr_x</span><span class="si">}</span><span class="s2">_mean_dp&quot;</span><span class="p">]</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">ht</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">normalization_contig</span><span class="si">}</span><span class="s2">_mean_dp&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">chr_y</span><span class="si">}</span><span class="s2">_ploidy&quot;</span><span class="p">:</span> <span class="n">ht</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">chr_y</span><span class="si">}</span><span class="s2">_mean_dp&quot;</span><span class="p">]</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">ht</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">normalization_contig</span><span class="si">}</span><span class="s2">_mean_dp&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="compute_coverage_stats"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.compute_coverage_stats">[docs]</a><span class="k">def</span> <span class="nf">compute_coverage_stats</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">reference_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">coverage_over_x_bins</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute coverage statistics for every base of the `reference_ht` provided.</span>

<span class="sd">    The following coverage stats are calculated:</span>
<span class="sd">        - mean</span>
<span class="sd">        - median</span>
<span class="sd">        - total DP</span>
<span class="sd">        - fraction of samples with coverage above X, for each x in `coverage_over_x_bins`</span>

<span class="sd">    The `reference_ht` is a table that contains row for each locus coverage should be computed on.</span>
<span class="sd">    It needs to be keyed with the same keys as `mt`, typically either `locus` or `locus, alleles`.</span>
<span class="sd">    The `reference_ht` can e.g. be created using `get_reference_ht`</span>

<span class="sd">    :param mt: Input sparse MT</span>
<span class="sd">    :param reference_ht: Input reference HT</span>
<span class="sd">    :param coverage_over_x_bins: List of boundaries for computing samples over X</span>
<span class="sd">    :return: Table with per-base coverage stats</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">count_cols</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computing coverage stats on </span><span class="si">{</span><span class="n">n_samples</span><span class="si">}</span><span class="s2"> samples.&quot;</span><span class="p">)</span>

    <span class="c1"># Create an outer join with the reference Table</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">select_entries</span><span class="p">(</span><span class="s2">&quot;END&quot;</span><span class="p">,</span> <span class="s2">&quot;DP&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">select_cols</span><span class="p">()</span><span class="o">.</span><span class="n">select_rows</span><span class="p">()</span>
    <span class="n">col_key_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">col_key</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">_localize_entries</span><span class="p">(</span><span class="s2">&quot;__entries&quot;</span><span class="p">,</span> <span class="s2">&quot;__cols&quot;</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">reference_ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="o">*</span><span class="n">mt</span><span class="o">.</span><span class="n">row_key</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">_in_ref</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">__entries</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span>
            <span class="n">t</span><span class="o">.</span><span class="n">__entries</span><span class="p">,</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">__entries</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">element_type</span><span class="p">)),</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">_unlocalize_entries</span><span class="p">(</span><span class="s2">&quot;__entries&quot;</span><span class="p">,</span> <span class="s2">&quot;__cols&quot;</span><span class="p">,</span> <span class="n">col_key_fields</span><span class="p">)</span>

    <span class="c1"># Densify</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">densify</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span>

    <span class="c1"># Filter rows where the reference is missing</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_in_ref</span><span class="p">)</span>

    <span class="c1"># Unfilter entries so that entries with no ref block overlap aren&#39;t null</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">unfilter_entries</span><span class="p">()</span>

    <span class="c1"># Compute coverage stats</span>
    <span class="n">coverage_over_x_bins</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">coverage_over_x_bins</span><span class="p">)</span>
    <span class="n">max_coverage_bin</span> <span class="o">=</span> <span class="n">coverage_over_x_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">hl_coverage_over_x_bins</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coverage_over_x_bins</span><span class="p">)</span>

    <span class="c1"># This expression creates a counter DP -&gt; number of samples for DP between 0 and max_coverage_bin</span>
    <span class="n">coverage_counter_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">counter</span><span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">max_coverage_bin</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">DP</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">)</span>

    <span class="c1"># This expression aggregates the DP counter in reverse order of the coverage_over_x_bins</span>
    <span class="c1"># and computes the cumulative sum over them.</span>
    <span class="c1">#  It needs to be in reverse order because we want the sum over samples covered by &gt; X.</span>
    <span class="n">count_array_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">cumulative_sum</span><span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">coverage_counter_expr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">max_coverage_bin</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="p">]</span>  <span class="c1"># The coverage was already floored to the max_coverage_bin, so no more aggregation is needed for the max bin</span>
        <span class="p">)</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>  <span class="c1"># For each of the other bins, coverage needs to be summed between the boundaries</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">hl_coverage_over_x_bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">step</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span>
                        <span class="n">hl_coverage_over_x_bins</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">hl_coverage_over_x_bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">coverage_counter_expr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">mean_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">DP</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Annotate rows now</span>
    <span class="k">return</span> <span class="n">mt</span><span class="o">.</span><span class="n">select_rows</span><span class="p">(</span>
        <span class="n">mean</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_nan</span><span class="p">(</span><span class="n">mean_expr</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mean_expr</span><span class="p">),</span>
        <span class="n">median_approx</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">approx_median</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">DP</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">total_DP</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">DP</span><span class="p">),</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;over_</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">count_array_expr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_samples</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">coverage_over_x_bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
                <span class="p">),</span>  <span class="c1"># Reverse the bin index as count_array_expr has the reverse order</span>
                <span class="n">coverage_over_x_bins</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">},</span>
    <span class="p">)</span><span class="o">.</span><span class="n">rows</span><span class="p">()</span></div>


<div class="viewcode-block" id="filter_ref_blocks"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.filter_ref_blocks">[docs]</a><span class="k">def</span> <span class="nf">filter_ref_blocks</span><span class="p">(</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter ref blocks out of the Table or MatrixTable.</span>

<span class="sd">    :param t: Input MT/HT</span>
<span class="sd">    :return: MT/HT with ref blocks removed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">((</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">alleles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">filter</span><span class="p">((</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">alleles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">t</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>