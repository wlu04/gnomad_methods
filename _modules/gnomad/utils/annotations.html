<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gnomad.utils.annotations &mdash; gnomad master documentation</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> gnomad
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resource_sources.html">Resource Sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Change Log</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">gnomad</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>gnomad.utils.annotations</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gnomad.utils.annotations</h1><div class="highlight"><pre>
<span></span><span class="c1"># noqa: D100</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">hail</span> <span class="k">as</span> <span class="nn">hl</span>
<span class="kn">from</span> <span class="nn">gnomad.utils.gen_stats</span> <span class="kn">import</span> <span class="n">to_phred</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(asctime)s</span><span class="s2"> (</span><span class="si">%(name)s</span><span class="s2"> </span><span class="si">%(lineno)s</span><span class="s2">): </span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">datefmt</span><span class="o">=</span><span class="s2">&quot;%m/</span><span class="si">%d</span><span class="s2">/%Y %I:%M:%S %p&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>

<span class="n">ANNOTATIONS_HISTS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;FS&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>  <span class="c1"># NOTE: in 2.0.2 release this was on (0,20)</span>
    <span class="s2">&quot;InbreedingCoeff&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>
    <span class="s2">&quot;MQ&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span>
    <span class="s2">&quot;RAW_MQ&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">33</span><span class="p">),</span>
    <span class="s2">&quot;MQRankSum&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span>
    <span class="s2">&quot;QD&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span>
    <span class="s2">&quot;ReadPosRankSum&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span>
    <span class="s2">&quot;SOR&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>
    <span class="s2">&quot;BaseQRankSum&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span>
    <span class="s2">&quot;ClippingRankSum&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span>
    <span class="s2">&quot;DP&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span>  <span class="c1"># NOTE: in 2.0.2 release this was on (0,8)</span>
    <span class="s2">&quot;VQSLOD&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span>  <span class="c1"># NOTE: in 2.0.2 release this was on (-20,20)</span>
    <span class="s2">&quot;AS_VQSLOD&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span>
    <span class="s2">&quot;rf_tp_probability&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>
    <span class="s2">&quot;pab_max&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>
<span class="p">}</span>


<div class="viewcode-block" id="pop_max_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.pop_max_expr">[docs]</a><span class="k">def</span> <span class="nf">pop_max_expr</span><span class="p">(</span>
    <span class="n">freq</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">freq_meta</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">pops_to_exclude</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Create an expression containing the frequency information about the population that has the highest AF in `freq_meta`.</span>

<span class="sd">    Populations specified in `pops_to_exclude` are excluded and only frequencies from adj populations are considered.</span>

<span class="sd">    This resulting struct contains the following fields:</span>

<span class="sd">        - AC: int32</span>
<span class="sd">        - AF: float64</span>
<span class="sd">        - AN: int32</span>
<span class="sd">        - homozygote_count: int32</span>
<span class="sd">        - pop: str</span>

<span class="sd">    :param freq: ArrayExpression of Structs with fields [&#39;AC&#39;, &#39;AF&#39;, &#39;AN&#39;, &#39;homozygote_count&#39;]</span>
<span class="sd">    :param freq_meta: ArrayExpression of meta dictionaries corresponding to freq (as returned by annotate_freq)</span>
<span class="sd">    :param pops_to_exclude: Set of populations to skip for popmax calcluation</span>

<span class="sd">    :return: Popmax struct</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_pops_to_exclude</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="n">pops_to_exclude</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pops_to_exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="n">hl</span><span class="o">.</span><span class="n">empty_set</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tstr</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># pylint: disable=invalid-unary-operand-type</span>
    <span class="n">popmax_freq_indices</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">))</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="s2">&quot;pop&quot;</span><span class="p">})</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;adj&quot;</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">_pops_to_exclude</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;pop&quot;</span><span class="p">]))</span>
    <span class="p">)</span>
    <span class="n">freq_filtered</span> <span class="o">=</span> <span class="n">popmax_freq_indices</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">pop</span><span class="o">=</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;pop&quot;</span><span class="p">])</span>
    <span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">AC</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">sorted_freqs</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">sorted</span><span class="p">(</span><span class="n">freq_filtered</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">AF</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">sorted_freqs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sorted_freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="project_max_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.project_max_expr">[docs]</a><span class="k">def</span> <span class="nf">project_max_expr</span><span class="p">(</span>
    <span class="n">project_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">,</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
    <span class="n">alleles_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">n_projects</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an expression that computes allele frequency information by project for the `n_projects` with the largest AF at this row.</span>

<span class="sd">    Will return an array with one element per non-reference allele.</span>

<span class="sd">    Each of these elements is itself an array of structs with the following fields:</span>

<span class="sd">        - AC: int32</span>
<span class="sd">        - AF: float64</span>
<span class="sd">        - AN: int32</span>
<span class="sd">        - homozygote_count: int32</span>
<span class="sd">        - project: str</span>

<span class="sd">    .. note::</span>

<span class="sd">        Only projects with AF &gt; 0 are returned.</span>
<span class="sd">        In case of ties, the project ordering is not guaranteed, and at most `n_projects` are returned.</span>

<span class="sd">    :param project_expr: column expression containing the project</span>
<span class="sd">    :param gt_expr: entry expression containing the genotype</span>
<span class="sd">    :param alleles_expr: row expression containing the alleles</span>
<span class="sd">    :param n_projects: Maximum number of projects to return for each row</span>
<span class="sd">    :return: projectmax expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_alleles</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">alleles_expr</span><span class="p">)</span>

    <span class="c1"># compute call stats by  project</span>
    <span class="n">project_cs</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">project_expr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">call_stats</span><span class="p">(</span><span class="n">gt_expr</span><span class="p">,</span> <span class="n">alleles_expr</span><span class="p">))</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
        <span class="n">n_alleles</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># Exclude monomorphic sites</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_alleles</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">sorted</span><span class="p">(</span>
                <span class="n">project_cs</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                    <span class="c1"># filter to projects with AF &gt; 0</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AF</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span>
                    <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="p">),</span>
                <span class="c1"># order the callstats computed by AF in decreasing order</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AF</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span>
                <span class="c1"># take the n_projects projects with largest AF</span>
            <span class="p">)[:</span><span class="n">n_projects</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="c1"># add the project in the callstats struct</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
                    <span class="n">AC</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AC</span><span class="p">[</span><span class="n">ai</span><span class="p">],</span>
                    <span class="n">AF</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AF</span><span class="p">[</span><span class="n">ai</span><span class="p">],</span>
                    <span class="n">AN</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AN</span><span class="p">,</span>
                    <span class="n">homozygote_count</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">homozygote_count</span><span class="p">[</span><span class="n">ai</span><span class="p">],</span>
                    <span class="n">project</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="faf_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.faf_expr">[docs]</a><span class="k">def</span> <span class="nf">faf_expr</span><span class="p">(</span>
    <span class="n">freq</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">freq_meta</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">locus</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">LocusExpression</span><span class="p">,</span>
    <span class="n">pops_to_exclude</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">faf_thresholds</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the filtering allele frequency (FAF) for each threshold specified in `faf_thresholds`.</span>

<span class="sd">    See http://cardiodb.org/allelefrequencyapp/ for more information.</span>

<span class="sd">    The FAF is computed for each of the following population stratification if found in `freq_meta`:</span>

<span class="sd">        - All samples, with adj criteria</span>
<span class="sd">        - For each population, with adj criteria</span>
<span class="sd">        - For all sex/population on the non-PAR regions of sex chromosomes (will be missing on autosomes and PAR regions of sex chromosomes)</span>

<span class="sd">    Each of the FAF entry is a struct with one entry per threshold specified in `faf_thresholds` of type float64.</span>

<span class="sd">    This returns a tuple with two expressions:</span>

<span class="sd">        1. An array of FAF expressions as described above</span>
<span class="sd">        2. An array of dict containing the metadata for each of the array elements, in the same format as that produced by `annotate_freq`.</span>

<span class="sd">    :param freq: ArrayExpression of call stats structs (typically generated by hl.agg.call_stats)</span>
<span class="sd">    :param freq_meta: ArrayExpression of meta dictionaries corresponding to freq (typically generated using annotate_freq)</span>
<span class="sd">    :param locus: locus</span>
<span class="sd">    :param pops_to_exclude: Set of populations to exclude from faf calculation (typically bottlenecked or consanguineous populations)</span>
<span class="sd">    :param faf_thresholds: List of FAF thresholds to compute</span>
<span class="sd">    :return: (FAF expression, FAF metadata)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_pops_to_exclude</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="n">pops_to_exclude</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pops_to_exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="n">hl</span><span class="o">.</span><span class="n">empty_set</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tstr</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># pylint: disable=invalid-unary-operand-type</span>
    <span class="n">faf_freq_indices</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">))</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;group&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;adj&quot;</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="o">|</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;pop&quot;</span><span class="p">,</span> <span class="s2">&quot;group&quot;</span><span class="p">})</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">_pops_to_exclude</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;pop&quot;</span><span class="p">]))</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">sex_faf_freq_indices</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">))</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;group&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;adj&quot;</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;sex&quot;</span><span class="p">))</span>
        <span class="o">&amp;</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
            <span class="o">|</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;pop&quot;</span><span class="p">,</span> <span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="s2">&quot;sex&quot;</span><span class="p">})</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">_pops_to_exclude</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;pop&quot;</span><span class="p">]))</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">faf_expr</span> <span class="o">=</span> <span class="n">faf_freq_indices</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;faf</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">threshold</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">filtering_allele_frequency</span><span class="p">(</span>
                    <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AC</span><span class="p">,</span> <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AN</span><span class="p">,</span> <span class="n">threshold</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="n">faf_thresholds</span>
            <span class="p">}</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">faf_expr</span> <span class="o">=</span> <span class="n">faf_expr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
        <span class="n">sex_faf_freq_indices</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
                <span class="o">~</span><span class="n">locus</span><span class="o">.</span><span class="n">in_autosome_or_par</span><span class="p">(),</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
                    <span class="o">**</span><span class="p">{</span>
                        <span class="sa">f</span><span class="s2">&quot;faf</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">threshold</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">filtering_allele_frequency</span><span class="p">(</span>
                            <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AC</span><span class="p">,</span> <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AN</span><span class="p">,</span> <span class="n">threshold</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="n">faf_thresholds</span>
                    <span class="p">}</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">faf_meta</span> <span class="o">=</span> <span class="n">faf_freq_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sex_faf_freq_indices</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">faf_expr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">faf_meta</span><span class="p">)</span></div>


<div class="viewcode-block" id="qual_hist_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.qual_hist_expr">[docs]</a><span class="k">def</span> <span class="nf">qual_hist_expr</span><span class="p">(</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">gq_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dp_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ad_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">adj_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a struct expression with genotype quality histograms based on the arguments given (dp, gq, ad).</span>

<span class="sd">    .. note::</span>

<span class="sd">        - If `gt_expr` is provided, will return histograms for non-reference samples only as well as all samples.</span>
<span class="sd">        - `gt_expr` is required for the allele-balance histogram, as it is only computed on het samples.</span>
<span class="sd">        - If `adj_expr` is provided, additional histograms are computed using only adj samples.</span>

<span class="sd">    :param gt_expr: Entry expression containing genotype</span>
<span class="sd">    :param gq_expr: Entry expression containing genotype quality</span>
<span class="sd">    :param dp_expr: Entry expression containing depth</span>
<span class="sd">    :param ad_expr: Entry expression containing allelic depth (bi-allelic here)</span>
<span class="sd">    :param adj_expr: Entry expression containing adj (high quality) genotype status</span>
<span class="sd">    :return: Genotype quality histograms expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">qual_hists</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">gq_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qual_hists</span><span class="p">[</span><span class="s2">&quot;gq_hist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">gq_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dp_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qual_hists</span><span class="p">[</span><span class="s2">&quot;dp_hist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">dp_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">gt_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qual_hists</span> <span class="o">=</span> <span class="p">{</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">qual_hist_name</span><span class="si">}</span><span class="s2">_all&quot;</span><span class="p">:</span> <span class="n">qual_hist_expr</span>
                <span class="k">for</span> <span class="n">qual_hist_name</span><span class="p">,</span> <span class="n">qual_hist_expr</span> <span class="ow">in</span> <span class="n">qual_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">},</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">qual_hist_name</span><span class="si">}</span><span class="s2">_alt&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                    <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_non_ref</span><span class="p">(),</span> <span class="n">qual_hist_expr</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">qual_hist_name</span><span class="p">,</span> <span class="n">qual_hist_expr</span> <span class="ow">in</span> <span class="n">qual_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">},</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">ad_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">qual_hists</span><span class="p">[</span><span class="s2">&quot;ab_hist_alt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_het</span><span class="p">(),</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">ad_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">hl</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ad_expr</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">qual_hists</span> <span class="o">=</span> <span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">qual_hist_name</span><span class="si">}</span><span class="s2">_all&quot;</span><span class="p">:</span> <span class="n">qual_hist_expr</span>
            <span class="k">for</span> <span class="n">qual_hist_name</span><span class="p">,</span> <span class="n">qual_hist_expr</span> <span class="ow">in</span> <span class="n">qual_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="k">if</span> <span class="n">adj_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qual_hists</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">qual_hist_name</span><span class="si">}</span><span class="s2">_adj&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">adj_expr</span><span class="p">,</span> <span class="n">qual_hist_expr</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">qual_hist_name</span><span class="p">,</span> <span class="n">qual_hist_expr</span> <span class="ow">in</span> <span class="n">qual_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">qual_hists</span><span class="p">)</span></div>


<div class="viewcode-block" id="age_hists_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.age_hists_expr">[docs]</a><span class="k">def</span> <span class="nf">age_hists_expr</span><span class="p">(</span>
    <span class="n">adj_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">,</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
    <span class="n">age_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">,</span>
    <span class="n">lowest_boundary</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">highest_boundary</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
    <span class="n">n_bins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a StructExpression with the age histograms for hets and homs.</span>

<span class="sd">    :param adj_expr: Entry expression containing whether a genotype is high quality (adj) or not</span>
<span class="sd">    :param gt_expr: Entry expression containing the genotype</span>
<span class="sd">    :param age_expr: Col expression containing the sample&#39;s age</span>
<span class="sd">    :param lowest_boundary: Lowest bin boundary (any younger sample will be binned in n_smaller)</span>
<span class="sd">    :param highest_boundary: Highest bin boundary (any older sample will be binned in n_larger)</span>
<span class="sd">    :param n_bins: Total number of bins</span>
<span class="sd">    :return: A struct with `age_hist_het` and `age_hist_hom`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
        <span class="n">age_hist_het</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">adj_expr</span> <span class="o">&amp;</span> <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_het</span><span class="p">(),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">age_expr</span><span class="p">,</span> <span class="n">lowest_boundary</span><span class="p">,</span> <span class="n">highest_boundary</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">),</span>
        <span class="p">),</span>
        <span class="n">age_hist_hom</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">adj_expr</span> <span class="o">&amp;</span> <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_hom_var</span><span class="p">(),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">age_expr</span><span class="p">,</span> <span class="n">lowest_boundary</span><span class="p">,</span> <span class="n">highest_boundary</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">),</span>
        <span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="annotate_freq"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.annotate_freq">[docs]</a><span class="k">def</span> <span class="nf">annotate_freq</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">sex_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">pop_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">subpop_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">additional_strata_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">downsamplings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate `mt` with stratified allele frequencies.</span>

<span class="sd">    The output Matrix table will include:</span>
<span class="sd">        - row annotation `freq` containing the stratified allele frequencies</span>
<span class="sd">        - global annotation `freq_meta` with metadata</span>
<span class="sd">        - global annotation `freq_sample_count` with sample count information</span>

<span class="sd">    .. note::</span>

<span class="sd">        Currently this only supports bi-allelic sites.</span>
<span class="sd">        The input `mt` needs to have the following entry fields:</span>
<span class="sd">        - GT: a CallExpression containing the genotype</span>
<span class="sd">        - adj: a BooleanExpression containing whether the genotype is of high quality or not.</span>
<span class="sd">        All expressions arguments need to be expression on the input `mt`.</span>

<span class="sd">    .. rubric:: `freq` row annotation</span>

<span class="sd">    The `freq` row annotation is an Array of Struct, with each Struct containing the following fields:</span>

<span class="sd">        - AC: int32</span>
<span class="sd">        - AF: float64</span>
<span class="sd">        - AN: int32</span>
<span class="sd">        - homozygote_count: int32</span>

<span class="sd">    Each element of the array corresponds to a stratification of the data, and the metadata about these annotations is</span>
<span class="sd">    stored in the globals.</span>

<span class="sd">    .. rubric:: Global `freq_meta` metadata annotation</span>

<span class="sd">    The global annotation `freq_meta` is added to the input `mt`. It is a list of dict.</span>
<span class="sd">    Each element of the list contains metadata on a frequency stratification and the index in the list corresponds</span>
<span class="sd">    to the index of that frequency stratification in the `freq` row annotation.</span>

<span class="sd">    .. rubric:: Global `freq_sample_count` annotation</span>

<span class="sd">    The global annotation `freq_sample_count` is added to the input `mt`. This is a sample count per sample grouping</span>
<span class="sd">    defined in the `freq_meta` global annotation.</span>

<span class="sd">    .. rubric:: The `downsamplings` parameter</span>

<span class="sd">    If the `downsamplings` parameter is used, frequencies will be computed for all samples and by population</span>
<span class="sd">    (if `pop_expr` is specified) by downsampling the number of samples without replacement to each of the numbers specified in the</span>
<span class="sd">    `downsamplings` array, provided that there are enough samples in the dataset.</span>
<span class="sd">    In addition, if `pop_expr` is specified, a downsampling to each of the exact number of samples present in each population is added.</span>
<span class="sd">    Note that samples are randomly sampled only once, meaning that the lower downsamplings are subsets of the higher ones.</span>

<span class="sd">    :param mt: Input MatrixTable</span>
<span class="sd">    :param sex_expr: When specified, frequencies are stratified by sex. If `pop_expr` is also specified, then a pop/sex stratifiction is added.</span>
<span class="sd">    :param pop_expr: When specified, frequencies are stratified by population. If `sex_expr` is also specified, then a pop/sex stratifiction is added.</span>
<span class="sd">    :param subpop_expr: When specified, frequencies are stratified by sub-continental population. Note that `pop_expr` is required as well when using this option.</span>
<span class="sd">    :param additional_strata_expr: When specified, frequencies are stratified by the given additional strata found in the dict. This can e.g. be used to stratify by platform.</span>
<span class="sd">    :param downsamplings: When specified, frequencies are computed by downsampling the data to the number of samples given in the list. Note that if `pop_expr` is specified, downsamplings by population is also computed.</span>
<span class="sd">    :return: MatrixTable with `freq` annotation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">subpop_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pop_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;annotate_freq requires pop_expr when using subpop_expr&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">additional_strata_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">additional_strata_expr</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">_freq_meta_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">additional_strata_expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sex_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_freq_meta_expr</span> <span class="o">=</span> <span class="n">_freq_meta_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">sex</span><span class="o">=</span><span class="n">sex_expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pop_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_freq_meta_expr</span> <span class="o">=</span> <span class="n">_freq_meta_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">pop</span><span class="o">=</span><span class="n">pop_expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">subpop_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_freq_meta_expr</span> <span class="o">=</span> <span class="n">_freq_meta_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">subpop</span><span class="o">=</span><span class="n">subpop_expr</span><span class="p">)</span>

    <span class="c1"># Annotate cols with provided cuts</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span><span class="n">_freq_meta</span><span class="o">=</span><span class="n">_freq_meta_expr</span><span class="p">)</span>

    <span class="c1"># Get counters for sex, pop and subpop if set</span>
    <span class="n">cut_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">cut</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="p">[</span><span class="n">cut</span><span class="p">]),</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">counter</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="p">[</span><span class="n">cut</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">cut</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span>
        <span class="k">if</span> <span class="n">cut</span> <span class="o">!=</span> <span class="s2">&quot;subpop&quot;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="s2">&quot;subpop&quot;</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="p">:</span>
        <span class="n">cut_dict</span><span class="p">[</span><span class="s2">&quot;subpop&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">pop</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">subpop</span><span class="p">),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">counter</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="n">subpop</span><span class="o">=</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">subpop</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">pop</span><span class="p">)</span>
            <span class="p">),</span>
        <span class="p">)</span>

    <span class="n">cut_data</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">aggregate_cols</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">cut_dict</span><span class="p">))</span>
    <span class="n">sample_group_filters</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Create downsamplings if needed</span>
    <span class="k">if</span> <span class="n">downsamplings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Add exact pop size downsampling if pops were provided</span>
        <span class="k">if</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pop&quot;</span><span class="p">):</span>
            <span class="n">downsamplings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="n">downsamplings</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pop&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="p">)</span>  <span class="c1"># Add the pops values if not in yet</span>
            <span class="n">downsamplings</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">downsamplings</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pop&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span>
            <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">%d</span><span class="s2"> downsamplings: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">downsamplings</span><span class="p">),</span> <span class="n">downsamplings</span><span class="p">)</span>

        <span class="c1"># Shuffle the samples, then create a global index for downsampling</span>
        <span class="c1"># And a pop-index if pops were provided</span>
        <span class="n">downsampling_ht</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">cols</span><span class="p">()</span>
        <span class="n">downsampling_ht</span> <span class="o">=</span> <span class="n">downsampling_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">rand_unif</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">downsampling_ht</span> <span class="o">=</span> <span class="n">downsampling_ht</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">downsampling_ht</span><span class="o">.</span><span class="n">r</span><span class="p">)</span>
        <span class="n">scan_expr</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;global_idx&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">count</span><span class="p">()}</span>
        <span class="k">if</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pop&quot;</span><span class="p">):</span>
            <span class="n">scan_expr</span><span class="p">[</span><span class="s2">&quot;pop_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">counter</span><span class="p">(</span><span class="n">downsampling_ht</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">pop</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">downsampling_ht</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">pop</span><span class="p">,</span> <span class="mi">0</span>
            <span class="p">)</span>
        <span class="n">downsampling_ht</span> <span class="o">=</span> <span class="n">downsampling_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">scan_expr</span><span class="p">)</span>
        <span class="n">downsampling_ht</span> <span class="o">=</span> <span class="n">downsampling_ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">scan_expr</span><span class="p">)</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span><span class="n">downsampling</span><span class="o">=</span><span class="n">downsampling_ht</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">s</span><span class="p">])</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span><span class="n">downsamplings</span><span class="o">=</span><span class="n">downsamplings</span><span class="p">)</span>

        <span class="c1"># Create downsampled sample groups</span>
        <span class="n">sample_group_filters</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span>
                    <span class="p">{</span><span class="s2">&quot;downsampling&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">ds</span><span class="p">),</span> <span class="s2">&quot;pop&quot;</span><span class="p">:</span> <span class="s2">&quot;global&quot;</span><span class="p">},</span>
                    <span class="n">mt</span><span class="o">.</span><span class="n">downsampling</span><span class="o">.</span><span class="n">global_idx</span> <span class="o">&lt;</span> <span class="n">ds</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">downsamplings</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pop&quot;</span><span class="p">):</span>
            <span class="n">sample_group_filters</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span>
                        <span class="p">{</span><span class="s2">&quot;downsampling&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">ds</span><span class="p">),</span> <span class="s2">&quot;pop&quot;</span><span class="p">:</span> <span class="n">pop</span><span class="p">},</span>
                        <span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">downsampling</span><span class="o">.</span><span class="n">pop_idx</span> <span class="o">&lt;</span> <span class="n">ds</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">pop</span> <span class="o">==</span> <span class="n">pop</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">downsamplings</span>
                    <span class="k">for</span> <span class="n">pop</span><span class="p">,</span> <span class="n">pop_count</span> <span class="ow">in</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pop&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">ds</span> <span class="o">&lt;=</span> <span class="n">pop_count</span>
                <span class="p">]</span>
            <span class="p">)</span>

    <span class="c1"># Add all desired strata, starting with the full set and ending with downsamplings (if any)</span>
    <span class="n">sample_group_filters</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">[({},</span> <span class="kc">True</span><span class="p">)]</span>
        <span class="o">+</span> <span class="p">[({</span><span class="s2">&quot;pop&quot;</span><span class="p">:</span> <span class="n">pop</span><span class="p">},</span> <span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">pop</span> <span class="o">==</span> <span class="n">pop</span><span class="p">)</span> <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pop&quot;</span><span class="p">,</span> <span class="p">{})]</span>
        <span class="o">+</span> <span class="p">[({</span><span class="s2">&quot;sex&quot;</span><span class="p">:</span> <span class="n">sex</span><span class="p">},</span> <span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">sex</span> <span class="o">==</span> <span class="n">sex</span><span class="p">)</span> <span class="k">for</span> <span class="n">sex</span> <span class="ow">in</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sex&quot;</span><span class="p">,</span> <span class="p">{})]</span>
        <span class="o">+</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;pop&quot;</span><span class="p">:</span> <span class="n">pop</span><span class="p">,</span> <span class="s2">&quot;sex&quot;</span><span class="p">:</span> <span class="n">sex</span><span class="p">},</span>
                <span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">sex</span> <span class="o">==</span> <span class="n">sex</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">pop</span> <span class="o">==</span> <span class="n">pop</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">sex</span> <span class="ow">in</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sex&quot;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pop&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="p">]</span>
        <span class="o">+</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;subpop&quot;</span><span class="p">:</span> <span class="n">subpop</span><span class="o">.</span><span class="n">subpop</span><span class="p">,</span> <span class="s2">&quot;pop&quot;</span><span class="p">:</span> <span class="n">subpop</span><span class="o">.</span><span class="n">pop</span><span class="p">},</span>
                <span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">pop</span> <span class="o">==</span> <span class="n">subpop</span><span class="o">.</span><span class="n">pop</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">subpop</span> <span class="o">==</span> <span class="n">subpop</span><span class="o">.</span><span class="n">subpop</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">subpop</span> <span class="ow">in</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;subpop&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="p">]</span>
        <span class="o">+</span> <span class="p">[</span>
            <span class="p">({</span><span class="n">strata</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">s_value</span><span class="p">)},</span> <span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="p">[</span><span class="n">strata</span><span class="p">]</span> <span class="o">==</span> <span class="n">s_value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">strata</span> <span class="ow">in</span> <span class="n">additional_strata_expr</span>
            <span class="k">for</span> <span class="n">s_value</span> <span class="ow">in</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="p">{})</span>
        <span class="p">]</span>
        <span class="o">+</span> <span class="n">sample_group_filters</span>
    <span class="p">)</span>

    <span class="n">freq_sample_count</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">aggregate_cols</span><span class="p">(</span>
        <span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">count_where</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sample_group_filters</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Annotate columns with group_membership</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span><span class="n">group_membership</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sample_group_filters</span><span class="p">])</span>

    <span class="c1"># Create and annotate global expression with meta and sample count information</span>
    <span class="n">freq_meta_expr</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">dict</span><span class="p">(</span><span class="o">**</span><span class="n">sample_group</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">group</span><span class="o">=</span><span class="s2">&quot;adj&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">sample_group</span> <span class="ow">in</span> <span class="n">sample_group_filters</span>
    <span class="p">]</span>
    <span class="n">freq_meta_expr</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;group&quot;</span><span class="p">:</span> <span class="s2">&quot;raw&quot;</span><span class="p">})</span>
    <span class="n">freq_sample_count</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">freq_sample_count</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span>
        <span class="n">freq_meta</span><span class="o">=</span><span class="n">freq_meta_expr</span><span class="p">,</span> <span class="n">freq_sample_count</span><span class="o">=</span><span class="n">freq_sample_count</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Create frequency expression array from the sample groups</span>
    <span class="c1"># Adding sample_group_filters_range_array to reduce memory usage in this array_agg</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_rows</span><span class="p">(</span>
        <span class="n">sample_group_filters_range_array</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_group_filters</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">freq_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">mt</span><span class="o">.</span><span class="n">group_membership</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mt</span><span class="o">.</span><span class="n">adj</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">call_stats</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">alleles</span><span class="p">)</span>
        <span class="p">),</span>
        <span class="n">mt</span><span class="o">.</span><span class="n">sample_group_filters_range_array</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Insert raw as the second element of the array</span>
    <span class="n">freq_expr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">freq_expr</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
        <span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">call_stats</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">alleles</span><span class="p">)])</span>
        <span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">freq_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="p">)</span>

    <span class="c1"># Select non-ref allele (assumes bi-allelic)</span>
    <span class="n">freq_expr</span> <span class="o">=</span> <span class="n">freq_expr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">cs</span><span class="p">:</span> <span class="n">cs</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">AC</span><span class="o">=</span><span class="n">cs</span><span class="o">.</span><span class="n">AC</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">AF</span><span class="o">=</span><span class="n">cs</span><span class="o">.</span><span class="n">AF</span><span class="p">[</span>
                <span class="mi">1</span>
            <span class="p">],</span>  <span class="c1"># TODO This is NA in case AC and AN are 0 -- should we set it to 0?</span>
            <span class="n">homozygote_count</span><span class="o">=</span><span class="n">cs</span><span class="o">.</span><span class="n">homozygote_count</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Return MT with freq row annotation</span>
    <span class="k">return</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_rows</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">freq_expr</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;_freq_meta&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_lowqual_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.get_lowqual_expr">[docs]</a><span class="k">def</span> <span class="nf">get_lowqual_expr</span><span class="p">(</span>
    <span class="n">alleles</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">qual_approx_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">],</span>
    <span class="n">snv_phred_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">snv_phred_het_prior</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>  <span class="c1"># 1/1000</span>
    <span class="n">indel_phred_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">indel_phred_het_prior</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">39</span><span class="p">,</span>  <span class="c1"># 1/8,000</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute lowqual threshold expression for either split or unsplit alleles based on QUALapprox or AS_QUALapprox.</span>

<span class="sd">    .. note::</span>

<span class="sd">        When running This lowqual annotation using QUALapprox, it differs from the GATK LowQual filter.</span>
<span class="sd">        This is because GATK computes this annotation at the site level, which uses the least stringent prior for mixed sites.</span>
<span class="sd">        When run using AS_QUALapprox, this implementation can thus be more stringent for certain alleles at mixed sites.</span>

<span class="sd">    :param alleles: Array of alleles</span>
<span class="sd">    :param qual_approx_expr: QUALapprox or AS_QUALapprox</span>
<span class="sd">    :param snv_phred_threshold: Phred-scaled SNV &quot;emission&quot; threshold (similar to GATK emission threshold)</span>
<span class="sd">    :param snv_phred_het_prior: Phred-scaled SNV heterozygosity prior (30 = 1/1000 bases, GATK default)</span>
<span class="sd">    :param indel_phred_threshold: Phred-scaled indel &quot;emission&quot; threshold (similar to GATK emission threshold)</span>
<span class="sd">    :param indel_phred_het_prior: Phred-scaled indel heterozygosity prior (30 = 1/1000 bases, GATK default)</span>
<span class="sd">    :return: lowqual expression (BooleanExpression if `qual_approx_expr`is Numeric, Array[BooleanExpression] if `qual_approx_expr` is ArrayNumeric)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_snv_qual</span> <span class="o">=</span> <span class="n">snv_phred_threshold</span> <span class="o">+</span> <span class="n">snv_phred_het_prior</span>
    <span class="n">min_indel_qual</span> <span class="o">=</span> <span class="n">indel_phred_threshold</span> <span class="o">+</span> <span class="n">indel_phred_het_prior</span>
    <span class="n">min_mixed_qual</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">min_snv_qual</span><span class="p">,</span> <span class="n">min_indel_qual</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qual_approx_expr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">alleles</span><span class="p">))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">is_snp</span><span class="p">(</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alleles</span><span class="p">[</span><span class="n">ai</span><span class="p">]),</span>
                <span class="n">qual_approx_expr</span><span class="p">[</span><span class="n">ai</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_snv_qual</span><span class="p">,</span>
                <span class="n">qual_approx_expr</span><span class="p">[</span><span class="n">ai</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_indel_qual</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">alleles</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_snp</span><span class="p">(</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alleles</span><span class="p">[</span><span class="n">ai</span><span class="p">])</span>
                <span class="p">),</span>
                <span class="n">qual_approx_expr</span> <span class="o">&lt;</span> <span class="n">min_snv_qual</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">alleles</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_indel</span><span class="p">(</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alleles</span><span class="p">[</span><span class="n">ai</span><span class="p">])</span>
                <span class="p">),</span>
                <span class="n">qual_approx_expr</span> <span class="o">&lt;</span> <span class="n">min_indel_qual</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">qual_approx_expr</span> <span class="o">&lt;</span> <span class="n">min_mixed_qual</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="get_annotations_hists"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.get_annotations_hists">[docs]</a><span class="k">def</span> <span class="nf">get_annotations_hists</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">annotations_hists</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
    <span class="n">log10_annotations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;DP&quot;</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create histograms for variant metrics in ht.info.</span>

<span class="sd">    Used when creating site quality distribution json files.</span>

<span class="sd">    :param ht: Table with variant metrics</span>
<span class="sd">    :param annotations_hists: Dictionary of metrics names and their histogram values (start, end, bins)</span>
<span class="sd">    :param log10_annotations: List of metrics to log scale</span>
<span class="sd">    :return: Dictionary of merics and their histograms</span>
<span class="sd">    :rtype: Dict[str, hl.expr.StructExpression]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check all fields in ht.info and create histograms if they are in annotations_hists dict</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="n">field</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">field</span><span class="p">])</span> <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">log10_annotations</span> <span class="k">else</span> <span class="n">ht</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">field</span><span class="p">],</span>
            <span class="n">start</span><span class="p">,</span>
            <span class="n">end</span><span class="p">,</span>
            <span class="n">bins</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span> <span class="ow">in</span> <span class="n">annotations_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">row</span><span class="o">.</span><span class="n">info</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="create_frequency_bins_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.create_frequency_bins_expr">[docs]</a><span class="k">def</span> <span class="nf">create_frequency_bins_expr</span><span class="p">(</span>
    <span class="n">AC</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">,</span> <span class="n">AF</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create bins for frequencies in preparation for aggregating QUAL by frequency bin.</span>

<span class="sd">    Bins:</span>
<span class="sd">        - singleton</span>
<span class="sd">        - doubleton</span>
<span class="sd">        - 0.00005</span>
<span class="sd">        - 0.0001</span>
<span class="sd">        - 0.0002</span>
<span class="sd">        - 0.0005</span>
<span class="sd">        - 0.001,</span>
<span class="sd">        - 0.002</span>
<span class="sd">        - 0.005</span>
<span class="sd">        - 0.01</span>
<span class="sd">        - 0.02</span>
<span class="sd">        - 0.05</span>
<span class="sd">        - 0.1</span>
<span class="sd">        - 0.2</span>
<span class="sd">        - 0.5</span>
<span class="sd">        - 1</span>

<span class="sd">    NOTE: Frequencies should be frequencies from raw data.</span>
<span class="sd">    Used when creating site quality distribution json files.</span>

<span class="sd">    :param AC: Field in input that contains the allele count information</span>
<span class="sd">    :param AF: Field in input that contains the allele frequency information</span>
<span class="sd">    :return: Expression containing bin name</span>
<span class="sd">    :rtype: hl.expr.StringExpression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bin_expr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">AC</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;binned_singleton&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">AC</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;binned_doubleton&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AC</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.00005</span><span class="p">),</span> <span class="s2">&quot;binned_0.00005&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.00005</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.0001</span><span class="p">),</span> <span class="s2">&quot;binned_0.0001&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.0001</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.0002</span><span class="p">),</span> <span class="s2">&quot;binned_0.0002&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.0002</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.0005</span><span class="p">),</span> <span class="s2">&quot;binned_0.0005&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.0005</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">),</span> <span class="s2">&quot;binned_0.001&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.001</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.002</span><span class="p">),</span> <span class="s2">&quot;binned_0.002&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.002</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.005</span><span class="p">),</span> <span class="s2">&quot;binned_0.005&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.005</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">),</span> <span class="s2">&quot;binned_0.01&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.01</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.02</span><span class="p">),</span> <span class="s2">&quot;binned_0.02&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.02</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">),</span> <span class="s2">&quot;binned_0.05&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.05</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">),</span> <span class="s2">&quot;binned_0.1&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.2</span><span class="p">),</span> <span class="s2">&quot;binned_0.2&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">),</span> <span class="s2">&quot;binned_0.5&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;binned_1&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tstr</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">bin_expr</span></div>


<div class="viewcode-block" id="get_adj_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.get_adj_expr">[docs]</a><span class="k">def</span> <span class="nf">get_adj_expr</span><span class="p">(</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
    <span class="n">gq_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">],</span>
    <span class="n">dp_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">],</span>
    <span class="n">ad_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">,</span>
    <span class="n">adj_gq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="n">adj_dp</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">adj_ab</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="n">haploid_adj_dp</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get adj genotype annotation.</span>

<span class="sd">    Defaults correspond to gnomAD values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">gq_expr</span> <span class="o">&gt;=</span> <span class="n">adj_gq</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">gt_expr</span><span class="o">.</span><span class="n">is_haploid</span><span class="p">(),</span> <span class="n">dp_expr</span> <span class="o">&gt;=</span> <span class="n">haploid_adj_dp</span><span class="p">,</span> <span class="n">dp_expr</span> <span class="o">&gt;=</span> <span class="n">adj_dp</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="o">~</span><span class="n">gt_expr</span><span class="o">.</span><span class="n">is_het</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">gt_expr</span><span class="o">.</span><span class="n">is_het_ref</span><span class="p">(),</span> <span class="n">ad_expr</span><span class="p">[</span><span class="n">gt_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">/</span> <span class="n">dp_expr</span> <span class="o">&gt;=</span> <span class="n">adj_ab</span><span class="p">)</span>
            <span class="o">.</span><span class="n">default</span><span class="p">(</span>
                <span class="p">(</span><span class="n">ad_expr</span><span class="p">[</span><span class="n">gt_expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">/</span> <span class="n">dp_expr</span> <span class="o">&gt;=</span> <span class="n">adj_ab</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">ad_expr</span><span class="p">[</span><span class="n">gt_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">/</span> <span class="n">dp_expr</span> <span class="o">&gt;=</span> <span class="n">adj_ab</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="annotate_adj"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.annotate_adj">[docs]</a><span class="k">def</span> <span class="nf">annotate_adj</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">adj_gq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="n">adj_dp</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">adj_ab</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="n">haploid_adj_dp</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate genotypes with adj criteria (assumes diploid).</span>

<span class="sd">    Defaults correspond to gnomAD values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_entries</span><span class="p">(</span>
        <span class="n">adj</span><span class="o">=</span><span class="n">get_adj_expr</span><span class="p">(</span>
            <span class="n">mt</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">GQ</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">DP</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">AD</span><span class="p">,</span> <span class="n">adj_gq</span><span class="p">,</span> <span class="n">adj_dp</span><span class="p">,</span> <span class="n">adj_ab</span><span class="p">,</span> <span class="n">haploid_adj_dp</span>
        <span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="add_variant_type"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.add_variant_type">[docs]</a><span class="k">def</span> <span class="nf">add_variant_type</span><span class="p">(</span><span class="n">alt_alleles</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Get Struct of variant_type and n_alt_alleles from ArrayExpression of Strings (all alleles).&quot;&quot;&quot;</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">alt_alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">alts</span> <span class="o">=</span> <span class="n">alt_alleles</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">non_star_alleles</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span> <span class="o">!=</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">alts</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
        <span class="n">variant_type</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_snp</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">non_star_alleles</span><span class="p">),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">non_star_alleles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;multi-snv&quot;</span><span class="p">,</span> <span class="s2">&quot;snv&quot;</span><span class="p">),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_indel</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">non_star_alleles</span><span class="p">),</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">non_star_alleles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;multi-indel&quot;</span><span class="p">,</span> <span class="s2">&quot;indel&quot;</span><span class="p">),</span>
                <span class="s2">&quot;mixed&quot;</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="p">),</span>
        <span class="n">n_alt_alleles</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">non_star_alleles</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="annotation_type_is_numeric"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.annotation_type_is_numeric">[docs]</a><span class="k">def</span> <span class="nf">annotation_type_is_numeric</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an annotation type, return whether it is a numerical type or not.</span>

<span class="sd">    :param t: Type to test</span>
<span class="sd">    :return: If the input type is numeric</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tint64</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tfloat32</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tfloat64</span><span class="p">)</span></div>


<div class="viewcode-block" id="annotation_type_in_vcf_info"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.annotation_type_in_vcf_info">[docs]</a><span class="k">def</span> <span class="nf">annotation_type_in_vcf_info</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an annotation type, returns whether that type can be natively exported to a VCF INFO field.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Types that aren&#39;t natively exportable to VCF will be converted to String on export.</span>

<span class="sd">    :param t: Type to test</span>
<span class="sd">    :return: If the input type can be exported to VCF</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">annotation_type_is_numeric</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tstr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tbool</span><span class="p">)</span>
        <span class="ow">or</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tarray</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tset</span><span class="p">))</span>
            <span class="ow">and</span> <span class="n">annotation_type_in_vcf_info</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">element_type</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="bi_allelic_site_inbreeding_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.bi_allelic_site_inbreeding_expr">[docs]</a><span class="k">def</span> <span class="nf">bi_allelic_site_inbreeding_expr</span><span class="p">(</span>
    <span class="n">call</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float32Expression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the site inbreeding coefficient as an expression to be computed on a MatrixTable.</span>

<span class="sd">    This is implemented based on the GATK InbreedingCoeff metric:</span>
<span class="sd">    https://software.broadinstitute.org/gatk/documentation/article.php?id=8032</span>

<span class="sd">    .. note::</span>

<span class="sd">        The computation is run based on the counts of alternate alleles and thus should only be run on bi-allelic sites.</span>

<span class="sd">    :param call: Expression giving the calls in the MT</span>
<span class="sd">    :return: Site inbreeding coefficient expression</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">inbreeding_coeff</span><span class="p">(</span>
        <span class="n">gt_counts</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">DictExpression</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float32Expression</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="n">q</span> <span class="o">*</span> <span class="n">n</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">inbreeding_coeff</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">counter</span><span class="p">(</span><span class="n">call</span><span class="o">.</span><span class="n">n_alt_alleles</span><span class="p">()))</span></div>


<div class="viewcode-block" id="fs_from_sb"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.fs_from_sb">[docs]</a><span class="k">def</span> <span class="nf">fs_from_sb</span><span class="p">(</span>
    <span class="n">sb</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">],</span>
    <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">min_cell_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
    <span class="n">min_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">min_p_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-320</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute `FS` (Fisher strand balance) annotation from  the `SB` (strand balance table) field.</span>

<span class="sd">    `FS` is the phred-scaled value of the double-sided Fisher exact test on strand balance.</span>

<span class="sd">    Using default values will have the same behavior as the GATK implementation, that is:</span>
<span class="sd">    - If sum(counts) &gt; 2*`min_cell_count` (default to GATK value of 200), they are normalized</span>
<span class="sd">    - If sum(counts) &lt; `min_count` (default to GATK value of 4), returns missing</span>
<span class="sd">    - Any p-value &lt; `min_p_value` (default to GATK value of 1e-320) is truncated to that value</span>

<span class="sd">    In addition to the default GATK behavior, setting `normalize` to `False` will perform a chi-squared test</span>
<span class="sd">    for large counts (&gt; `min_cell_count`) instead of normalizing the cell values.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This function can either take</span>
<span class="sd">        - an array of length four containing the forward and reverse strands&#39; counts of ref and alt alleles: [ref fwd, ref rev, alt fwd, alt rev]</span>
<span class="sd">        - a two dimensional array with arrays of length two, containing the counts: [[ref fwd, ref rev], [alt fwd, alt rev]]</span>

<span class="sd">    GATK code here: https://github.com/broadinstitute/gatk/blob/master/src/main/java/org/broadinstitute/hellbender/tools/walkers/annotator/FisherStrand.java</span>

<span class="sd">    :param sb: Count of ref/alt reads on each strand</span>
<span class="sd">    :param normalize: Whether to normalize counts is sum(counts) &gt; min_cell_count (normalize=True), or use a chi sq instead of FET (normalize=False)</span>
<span class="sd">    :param min_cell_count: Maximum count for performing a FET</span>
<span class="sd">    :param min_count: Minimum total count to output FS (otherwise null it output)</span>
<span class="sd">    :return: FS value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">):</span>
        <span class="n">sb</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">sb</span><span class="p">)</span>

    <span class="n">sb_sum</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">sb</span><span class="p">)</span>

    <span class="c1"># Normalize table if counts get too large</span>
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">fs_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">sb</span><span class="p">,</span> <span class="n">sb_sum</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
                <span class="n">sb_sum</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">min_cell_count</span><span class="p">,</span>
                <span class="n">sb</span><span class="p">,</span>
                <span class="n">sb</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="p">(</span><span class="n">sb_sum</span> <span class="o">/</span> <span class="n">min_cell_count</span><span class="p">))),</span>
            <span class="p">),</span>
            <span class="n">sb</span><span class="p">,</span>
            <span class="n">sb_sum</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># FET</span>
        <span class="n">fs_expr</span> <span class="o">=</span> <span class="n">to_phred</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">fisher_exact_test</span><span class="p">(</span>
                    <span class="n">fs_expr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fs_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fs_expr</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">fs_expr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="p">)</span><span class="o">.</span><span class="n">p_value</span><span class="p">,</span>
                <span class="n">min_p_value</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fs_expr</span> <span class="o">=</span> <span class="n">to_phred</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">contingency_table_test</span><span class="p">(</span>
                    <span class="n">sb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sb</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sb</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">min_cell_count</span><span class="o">=</span><span class="n">min_cell_count</span>
                <span class="p">)</span><span class="o">.</span><span class="n">p_value</span><span class="p">,</span>
                <span class="n">min_p_value</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Return null if counts &lt;= `min_count`</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
        <span class="n">sb_sum</span> <span class="o">&gt;</span> <span class="n">min_count</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fs_expr</span><span class="p">)</span>  <span class="c1"># Needed to avoid -0.0 values</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="sor_from_sb"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.sor_from_sb">[docs]</a><span class="k">def</span> <span class="nf">sor_from_sb</span><span class="p">(</span>
    <span class="n">sb</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute `SOR` (Symmetric Odds Ratio test) annotation from  the `SB` (strand balance table) field.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This function can either take</span>
<span class="sd">        - an array of length four containing the forward and reverse strands&#39; counts of ref and alt alleles: [ref fwd, ref rev, alt fwd, alt rev]</span>
<span class="sd">        - a two dimensional array with arrays of length two, containing the counts: [[ref fwd, ref rev], [alt fwd, alt rev]]</span>

<span class="sd">    GATK code here: https://github.com/broadinstitute/gatk/blob/master/src/main/java/org/broadinstitute/hellbender/tools/walkers/annotator/StrandOddsRatio.java</span>

<span class="sd">    :param sb: Count of ref/alt reads on each strand</span>
<span class="sd">    :return: SOR value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">):</span>
        <span class="n">sb</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">sb</span><span class="p">)</span>

    <span class="n">sb</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">ref_fw</span> <span class="o">=</span> <span class="n">sb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ref_rv</span> <span class="o">=</span> <span class="n">sb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">alt_fw</span> <span class="o">=</span> <span class="n">sb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">alt_rv</span> <span class="o">=</span> <span class="n">sb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">symmetrical_ratio</span> <span class="o">=</span> <span class="p">((</span><span class="n">ref_fw</span> <span class="o">*</span> <span class="n">alt_rv</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">alt_fw</span> <span class="o">*</span> <span class="n">ref_rv</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">alt_fw</span> <span class="o">*</span> <span class="n">ref_rv</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ref_fw</span> <span class="o">*</span> <span class="n">alt_rv</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">ref_ratio</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ref_rv</span><span class="p">,</span> <span class="n">ref_fw</span><span class="p">)</span> <span class="o">/</span> <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ref_rv</span><span class="p">,</span> <span class="n">ref_fw</span><span class="p">)</span>
    <span class="n">alt_ratio</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">alt_fw</span><span class="p">,</span> <span class="n">alt_rv</span><span class="p">)</span> <span class="o">/</span> <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">alt_fw</span><span class="p">,</span> <span class="n">alt_rv</span><span class="p">)</span>
    <span class="n">sor</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">symmetrical_ratio</span><span class="p">)</span> <span class="o">+</span> <span class="n">hl</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ref_ratio</span><span class="p">)</span> <span class="o">-</span> <span class="n">hl</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">alt_ratio</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sor</span></div>


<div class="viewcode-block" id="bi_allelic_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.bi_allelic_expr">[docs]</a><span class="k">def</span> <span class="nf">bi_allelic_expr</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a boolean expression selecting bi-allelic sites only, accounting for whether the input MT/HT was split.</span>

<span class="sd">    :param t: Input HT/MT</span>
<span class="sd">    :return: Boolean expression selecting only bi-allelic sites</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="o">~</span><span class="n">t</span><span class="o">.</span><span class="n">was_split</span> <span class="k">if</span> <span class="s2">&quot;was_split&quot;</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">row</span> <span class="k">else</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">alleles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="unphase_call_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.unphase_call_expr">[docs]</a><span class="k">def</span> <span class="nf">unphase_call_expr</span><span class="p">(</span><span class="n">call_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate unphased version of a call expression (which can be phased or not).</span>

<span class="sd">    :param call_expr: Input call expression</span>
<span class="sd">    :return: unphased call expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">call_expr</span><span class="o">.</span><span class="n">is_diploid</span><span class="p">(),</span> <span class="n">hl</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">call_expr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">call_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">phased</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">call_expr</span><span class="o">.</span><span class="n">is_haploid</span><span class="p">(),</span> <span class="n">hl</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">call_expr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">phased</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tcall</span><span class="p">))</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="region_flag_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.region_flag_expr">[docs]</a><span class="k">def</span> <span class="nf">region_flag_expr</span><span class="p">(</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">],</span>
    <span class="n">non_par</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prob_regions</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a `region_flag` struct that contains flags for problematic regions (i.e., LCR, decoy, segdup, and nonpar regions).</span>

<span class="sd">    .. note:: No hg38 resources for decoy or self chain are available yet.</span>

<span class="sd">    :param t: Input Table/MatrixTable</span>
<span class="sd">    :param non_par: If True, flag loci that occur within pseudoautosomal regions on sex chromosomes</span>
<span class="sd">    :param prob_regions: If supplied, flag loci that occur within regions defined in Hail Table(s)</span>
<span class="sd">    :return: `region_flag` struct row annotation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prob_flags_expr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;non_par&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">()</span> <span class="o">|</span> <span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">())}</span> <span class="k">if</span> <span class="n">non_par</span> <span class="k">else</span> <span class="p">{}</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">prob_regions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prob_flags_expr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="n">region_name</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">region_table</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">region_name</span><span class="p">,</span> <span class="n">region_table</span> <span class="ow">in</span> <span class="n">prob_regions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">prob_flags_expr</span><span class="p">)</span></div>


<div class="viewcode-block" id="missing_callstats_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.missing_callstats_expr">[docs]</a><span class="k">def</span> <span class="nf">missing_callstats_expr</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a missing callstats struct for insertion into frequency annotation arrays when data is missing.</span>

<span class="sd">    :return: Hail Struct with missing values for each callstats element</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
        <span class="n">AC</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">),</span>
        <span class="n">AF</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tfloat64</span><span class="p">),</span>
        <span class="n">AN</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">),</span>
        <span class="n">homozygote_count</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="set_female_y_metrics_to_na_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.set_female_y_metrics_to_na_expr">[docs]</a><span class="k">def</span> <span class="nf">set_female_y_metrics_to_na_expr</span><span class="p">(</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set Y-variant frequency callstats for female-specific metrics to missing structs.</span>

<span class="sd">    .. note:: Requires freq, freq_meta, and freq_index_dict annotations to be present in Table or MatrixTable</span>

<span class="sd">    :param t: Table or MatrixTable for which to adjust female metrics</span>
<span class="sd">    :return: Hail array expression to set female Y-variant metrics to missing values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">female_idx</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">freq_index_dict</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;XX&quot;</span><span class="p">),</span> <span class="n">t</span><span class="o">.</span><span class="n">freq_index_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
    <span class="p">)</span>
    <span class="n">freq_idx_range</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">freq_meta</span><span class="p">))</span>

    <span class="n">new_freq_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
        <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">()</span> <span class="o">|</span> <span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_par</span><span class="p">()),</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
                <span class="n">female_idx</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">missing_callstats_expr</span><span class="p">(),</span> <span class="n">t</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="p">),</span>
            <span class="n">freq_idx_range</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">t</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">new_freq_expr</span></div>


<div class="viewcode-block" id="hemi_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.hemi_expr">[docs]</a><span class="k">def</span> <span class="nf">hemi_expr</span><span class="p">(</span>
    <span class="n">locus</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">LocusExpression</span><span class="p">,</span>
    <span class="n">sex_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">,</span>
    <span class="n">gt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
    <span class="n">male_str</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;XY&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return whether genotypes are hemizygous.</span>

<span class="sd">    Return missing expression if locus is not in chrX/chrY non-PAR regions.</span>

<span class="sd">    :param locus: Input locus.</span>
<span class="sd">    :param sex_expr: Input StringExpression indicating whether sample is XX or XY.</span>
<span class="sd">    :param gt: Input genotype.</span>
<span class="sd">    :param xy_str: String indicating whether sample is XY. Default is &quot;XY&quot;.</span>
<span class="sd">    :return: BooleanExpression indicating whether genotypes are hemizygous.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
        <span class="n">locus</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">()</span> <span class="o">|</span> <span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">(),</span>
        <span class="c1"># Haploid genotypes have a single integer, so checking if</span>
        <span class="c1"># mt.GT[0] is alternate allele</span>
        <span class="n">gt</span><span class="o">.</span><span class="n">is_haploid</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sex_expr</span> <span class="o">==</span> <span class="n">male_str</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">gt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>